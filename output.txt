Project Path: .dotfiles

Source Tree:

```
.dotfiles
├── software_list.json
├── LICENSE
├── setup_windows.sh
├── vim
├── bash
├── install.sh
├── oh-my-posh
├── setup_linux.sh
└── README.md

```

`/home/setuc/.dotfiles/software_list.json`:

```json
{
    "git": {
        "description": "Distributed version control system",
        "winget": "Git.Git",
        "apt": "git",
        "default": true
    },
    "oh-my-posh": {
        "description": "Prompt theme engine for any shell",
        "winget": "JanDeDobbeleer.OhMyPosh",
        "default": true,
        "apt": "custom",
        "custom_install": "curl -s https://ohmyposh.dev/install.sh | bash -s -- -d ~/bin"
    },
    "python": {
        "description": "Programming language",
        "winget": "Python.Python.3",
        "apt": "python3",
        "default": true
    },
    "7zip": {
        "description": "File archiver with a high compression ratio",
        "winget": "7zip.7zip",
        "apt": "p7zip-full",
        "default": false
    },
    "nodejs": {
        "description": "JavaScript runtime built on Chrome's V8 JavaScript engine",
        "winget": "OpenJS.NodeJS",
        "apt": "nodejs",
        "default": false
    }
}
```


`/home/setuc/.dotfiles/setup_windows.sh`:

```sh
# Setup script for Windows environment using winget and JSON list

# Read the software list
$softwareList = Get-Content -Raw -Path "software_list.json" | ConvertFrom-Json

# Function to prompt user for installation
function Prompt-ForInstallation {
    param (
        [string]$name,
        [string]$description,
        [bool]$default
    )
    $choice = Read-Host "Install $name ($description)? (Y/n)"
    if ($choice -eq "" -and $default) { return $true }
    return $choice.ToLower() -eq 'y'
}

# Check if winget is available
if (!(Get-Command winget -ErrorAction SilentlyContinue)) {
    Write-Host "Winget is not installed. Please install it from the Microsoft Store or update your Windows."
    exit 1
}

# Install selected software
foreach ($software in $softwareList.PSObject.Properties) {
    $name = $software.Name
    $info = $software.Value
    if (Prompt-ForInstallation -name $name -description $info.description -default $info.default) {
        Write-Host "Installing $name..."
        winget install $info.winget
    }
}

# Install Stow (not available in winget, so we'll use pip)
if (Prompt-ForInstallation -name "Stow" -description "Symlink farm manager" -default $true) {
    pip install stow
}

# Clone dotfiles repository
if (!(Test-Path $HOME\.dotfiles)) {
    git clone https://github.com/setuc/dotfiles.git $HOME\.dotfiles
}

# Use stow to symlink configurations
Set-Location $HOME\.dotfiles
stow -v -R -t ~ powershell
stow -v -R -t ~ oh-my-posh

# Update PowerShell profile
$profileContent = @"
using namespace System.Management.Automation
using namespace System.Management.Automation.Language
 
if (`$host.Name -eq 'ConsoleHost')
{
    Import-Module PSReadLine
}
Import-Module -Name Terminal-Icons
Import-Module PSReadLine
oh-my-posh init pwsh --config "`$env:POSH_THEMES_PATH\night-owl.omp.json" | Invoke-Expression
oh-my-posh init pwsh --config "`$HOME\.dotfiles\oh-my-posh\.poshthemes\jandedobbeleer.omp.json" | Invoke-Expression
Set-PSReadLineOption -PredictionSource History
Set-PSReadLineOption -PredictionViewStyle ListView
Set-PSReadLineOption -EditMode Windows
"@

$profileContent | Set-Content $PROFILE

# Install additional PowerShell modules
if (Prompt-ForInstallation -name "PSReadLine" -description "PowerShell module for enhanced command line editing" -default $true) {
    Install-Module -Name PSReadLine -Force
}
if (Prompt-ForInstallation -name "Terminal-Icons" -description "PowerShell module to show file and folder icons in the terminal" -default $true) {
    Install-Module -Name Terminal-Icons -Force
}

Write-Host "Windows setup complete!"
```

`/home/setuc/.dotfiles/install.sh`:

```sh
#!/bin/bash

# Function to check if a command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Function to install a package if it's not already installed
install_package() {
    if ! command_exists "$1"; then
        echo "Installing $1..."
        sudo apt-get update && sudo apt-get install -y "$1"
    else
        echo "$1 is already installed."
    fi
}

# Install Stow
install_package stow

# Clone dotfiles repository if it doesn't exist
DOTFILES_DIR="$HOME/.dotfiles"
if [ ! -d "$DOTFILES_DIR" ]; then
    echo "Cloning dotfiles repository..."
    git clone https://github.com/setuc/dotfiles.git "$DOTFILES_DIR"
fi

# Navigate to dotfiles directory
cd "$DOTFILES_DIR" || exit

# Use Stow to symlink configurations
echo "Stowing configurations..."
stow -v -R -t ~ bash
stow -v -R -t ~ vim

# Update .bashrc if necessary
if ! grep -q "source ~/.bash_aliases" "$HOME/.bashrc"; then
    echo 'if [ -f ~/.bash_aliases ]; then source ~/.bash_aliases; fi' >> "$HOME/.bashrc"
fi

# Additional setup steps can be added here

echo "Dotfiles setup complete!"

```

`/home/setuc/.dotfiles/setup_linux.sh`:

```sh
#!/bin/bash

# Setup script for Linux environment using apt and JSON list

# Function to prompt user for installation
prompt_for_installation() {
    local name=$1
    local description=$2
    local default=$3
    if [ "$default" = true ]; then
        local prompt="Y/n"
        local default_answer="Y"
    else
        local prompt="y/N"
        local default_answer="N"
    fi
    read -p "Install $name ($description)? [$prompt] " choice
    choice=${choice:-$default_answer}
    case "$choice" in
        y|Y ) return 0 ;;
        * ) return 1 ;;
    esac
}

# Read the software list
software_list=$(cat software_list.json)

# Update package lists
sudo apt update

# Install selected software
for software in $(echo "$software_list" | jq -r 'keys[]'); do
    description=$(echo "$software_list" | jq -r ".[\"$software\"].description")
    default=$(echo "$software_list" | jq -r ".[\"$software\"].default")
    apt_package=$(echo "$software_list" | jq -r ".[\"$software\"].apt")
    custom_install=$(echo "$software_list" | jq -r ".[\"$software\"].custom_install // empty")
    
    if prompt_for_installation "$software" "$description" "$default"; then
        echo "Installing $software..."
        if [ "$apt_package" != "custom" ]; then
            sudo apt install -y $apt_package
        elif [ -n "$custom_install" ]; then
            eval "$custom_install"
        else
            echo "Error: No installation method specified for $software"
        fi
    fi
done

# Install Stow if not already installed
if prompt_for_installation "Stow" "Symlink farm manager" true; then
    sudo apt install -y stow
fi

# Install Miniconda
if prompt_for_installation "Miniconda" "Minimal conda installer" true; then
    wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O miniconda.sh
    bash miniconda.sh -b -p $HOME/miniconda
    rm miniconda.sh
    echo 'export PATH="$HOME/miniconda/bin:$PATH"' >> $HOME/.bashrc
    source $HOME/.bashrc
fi

# Setup dotfiles
mkdir -p $HOME/.dotfiles
git clone https://github.com/setuc/dotfiles.git $HOME/.dotfiles
cd $HOME/.dotfiles

# Use stow to symlink configurations
stow -v -R -t ~ bash
stow -v -R -t ~ oh-my-posh

# Update .bashrc
echo 'export PATH=$PATH:$HOME/.local/bin' >> $HOME/.bashrc
echo 'eval "$(oh-my-posh init bash --config $HOME/.dotfiles/oh-my-posh/.poshthemes/night-owl.omp.json)"' >> $HOME/.bashrc
echo 'export PATH=$PATH:$HOME/bin' >> $HOME/.bashrc

# Source .bash_aliases (only if it's not already sourced in .bashrc)
if ! grep -q "source ~/.bash_aliases" $HOME/.bashrc; then
    echo 'if [ -f ~/.bash_aliases ]; then source ~/.bash_aliases; fi' >> $HOME/.bashrc
fi

# Setup bash completion scripts
mkdir -p $HOME/.bash_completion.d
cp $HOME/.dotfiles/bash_completion/* $HOME/.bash_completion.d/
echo 'for file in $HOME/.bash_completion.d/*; do source $file; done' >> $HOME/.bashrc

echo "Linux setup complete!"
```

`/home/setuc/.dotfiles/README.md`:

```md
# dotfiles
@setuc dotfiles


### Linux Fresh Install
    git clone https://github.com/setuc/dotfiles.git .dotfiles
    cd .dotfiles
    chmod +x setup_linux.sh 
    ./setup_linux.sh 


    When working through the Azure ML VM, this is how the .bashrc file looked in the end. 
    oh my posh was installed in 
    cd HOME/cloudfiles/code/Users/setuchokshi/
    mkdir bin
    curl -s https://ohmyposh.dev/install.sh | bash -s -- -d ./bin
    $HOME/cloudfiles/code/Users/setuchokshi/bin

## BashRC in azure.
    export PATH=$PATH:$HOME/cloudfiles/code/Users/setuchokshi/bin
    eval "$(oh-my-posh init bash --config $HOME/.dotfiles/oh-my-posh/.poshthemes/night-owl.omp.json)"
    if [ -f ~/.bash_aliases ]; then source ~/.bash_aliases; fi
    for file in $HOME/.bash_completion.d/*; do source $file; done

## Consider adding
git config --global user.name "Setuc"
git config --global user.email "setuc@noemail.com"

https://github.com/getnf/getnf?ref=linuxtldr.com


```