Project Path: bash

Source Tree:

```
bash
├── functions
│   ├── extract.sh
│   ├── azure
│   │   ├── enable_storage_key.sh
│   │   └── create_aml_env.sh
│   ├── prompt
│   │   └── update_prompt.sh
│   ├── utilities
│   │   └── download_verify_install.sh
│   └── conda
│       └── create_conda_env.sh
├── completions
│   ├── git-completion.bash
│   ├── custom_env_completion.sh
│   └── docker-completion.bash
└── aliases
    ├── docker.aliases
    ├── function_aliases.aliases
    ├── git.aliases
    ├── azure.aliases
    ├── kubernetes.aliases
    └── general.aliases

```

`/home/setuc/.dotfiles/bash/functions/extract.sh`:

```sh
# ~/functions/extract.sh  
  
# Function to extract various archive types  
extract() {  
    if [ -f "$1" ]; then  
        case "$1" in  
            *.tar.bz2)   tar xjf "$1"     ;;  
            *.tar.gz)    tar xzf "$1"     ;;  
            *.bz2)       bunzip2 "$1"     ;;  
            *.rar)       unrar x "$1"     ;;  
            *.gz)        gunzip "$1"      ;;  
            *.tar)       tar xf "$1"      ;;  
            *.tbz2)      tar xjf "$1"     ;;  
            *.tgz)       tar xzf "$1"     ;;  
            *.zip)       unzip "$1"       ;;  
            *.Z)         uncompress "$1"  ;;  
            *.7z)        7z x "$1"        ;;  
            *)           echo "Cannot extract '$1' via extract()" ;;  
        esac  
    else  
        echo "'$1' is not a valid file"  
    fi  
}  

```

`/home/setuc/.dotfiles/bash/functions/azure/enable_storage_key.sh`:

```sh
#!/bin/bash

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to list storage accounts and their settings
list_storage_accounts() {
    local total_count=0
    local enabled_count=0
    local disabled_count=0

    echo -e "${YELLOW}Current Storage Account Settings:${NC}"
    echo -e "${YELLOW}--------------------------------${NC}"
    for rg in $(az group list --query "[].name" -o tsv); do
        for sa in $(az storage account list --resource-group $rg --query "[].name" -o tsv); do
            allow_shared_key=$(az storage account show --name $sa --resource-group $rg --query "allowSharedKeyAccess" -o tsv)
            if [ "$allow_shared_key" = "true" ]; then
                echo -e "$sa (RG: $rg): Allow storage account key access - ${GREEN}$allow_shared_key${NC}"
                ((enabled_count++))
            else
                echo -e "$sa (RG: $rg): Allow storage account key access - ${RED}$allow_shared_key${NC}"
                ((disabled_count++))
            fi
            ((total_count++))
        done
    done
    echo ""
    echo -e "${YELLOW}Summary:${NC}"
    echo "  Total storage accounts: $total_count"
    echo -e "  Accounts with key access enabled: ${GREEN}$enabled_count${NC}"
    echo -e "  Accounts with key access disabled: ${RED}$disabled_count${NC}"
    echo ""
}

# Function to update a single storage account
update_storage_account() {
    local sa=$1
    local rg=$2
    allow_shared_key=$(az storage account show --name $sa --resource-group $rg --query "allowSharedKeyAccess" -o tsv)
    if [ "$allow_shared_key" = "false" ]; then
        echo -e "Enabling storage account key access for ${YELLOW}$sa${NC} in resource group ${YELLOW}$rg${NC}"
        az storage account update --name $sa --resource-group $rg --allow-shared-key-access true
        echo -e "${GREEN}Storage account key access has been enabled for $sa${NC}"
        return 0
    else
        echo -e "${YELLOW}$sa${NC} already has storage account key access enabled. Skipping."
        return 1
    fi
}

# Function to update all disabled storage accounts
update_all_storage_accounts() {
    local updated_count=0
    local total_count=0
    echo -e "${YELLOW}Updating all disabled storage accounts...${NC}"
    for rg in $(az group list --query "[].name" -o tsv); do
        for sa in $(az storage account list --resource-group $rg --query "[].name" -o tsv); do
            ((total_count++))
            if update_storage_account $sa $rg; then
                ((updated_count++))
            fi
        done
    done
    echo -e "${GREEN}Updated $updated_count out of $total_count storage accounts.${NC}"
}

# List all storage accounts
list_storage_accounts

# Main loop for user interaction
while true; do
    echo -e "${YELLOW}Enter the name of a storage account to update, 'all' to update all disabled accounts, or 'q' to quit:${NC}"
    read input
    if [ "$input" = "q" ]; then
        break
    elif [ "$input" = "all" ]; then
        update_all_storage_accounts
    else
        # Find the resource group for the given storage account
        rg=$(az storage account list --query "[?name=='$input'].resourceGroup" -o tsv)
        if [ -z "$rg" ]; then
            echo -e "${RED}Storage account $input not found. Please try again.${NC}"
        else
            update_storage_account $input $rg
        fi
    fi
    echo ""
done

echo "Exiting. Here's the final state of your storage accounts:"
list_storage_accounts

```

`/home/setuc/.dotfiles/bash/functions/azure/create_aml_env.sh`:

```sh
# ~/functions/azure/create_aml_env.sh  
  
# Function to create an Azure Machine Learning environment  
create_aml_env() {  
    # ANSI color codes  
    RED='\033[0;31m'  
    GREEN='\033[0;32m'  
    YELLOW='\033[1;33m'  
    NC='\033[0m' # No Color  
  
    # Default values  
    default_python_version="3.11"  
    default_env_name="myenv"  
    default_display_name="Python Environment"  
  
    # Prompt for key information  
    read -p "Enter environment name (default: $default_env_name): " env_name  
    env_name=${env_name:-$default_env_name}  
  
    read -p "Enter display name (default: $default_display_name): " display_name  
    display_name=${display_name:-$default_display_name}  
  
    echo "Select Python version:"  
    echo "1) 3.10"  
    echo "2) 3.11"  
    echo "3) 3.12"  
    read -p "Enter choice (default: 2 for 3.11): " python_choice  
    case $python_choice in  
        1) python_version="3.10" ;;  
        3) python_version="3.12" ;;  
        *) python_version=$default_python_version ;;  
    esac  
  
    echo -e "${YELLOW}Creating conda environment...${NC}"  
    conda create -n "$env_name" python="$python_version" ipykernel notebook -y  
  
    if [ $? -ne 0 ]; then  
        echo -e "${RED}Failed to create conda environment. Exiting.${NC}"  
        return 1  
    fi  
  
    echo -e "${YELLOW}Activating environment...${NC}"  
    conda activate "$env_name"  
  
    if [ $? -ne 0 ]; then  
        echo -e "${RED}Failed to activate conda environment. Exiting.${NC}"  
        return 1  
    fi  
  
    echo -e "${YELLOW}Installing additional packages...${NC}"  
    conda install -y pip  
    pip install azureml-core  
  
    echo -e "${YELLOW}Installing IPython kernel...${NC}"  
    python -m ipykernel install --user --name "$env_name" --display-name "$display_name"  
  
    if [ $? -ne 0 ]; then  
        echo -e "${RED}Failed to install IPython kernel. Exiting.${NC}"  
        return 1  
    fi  
  
    echo -e "${GREEN}Environment '$env_name' created and activated with display name '$display_name'${NC}"  
    echo -e "${GREEN}Python version: $python_version${NC}"  
}  

```

`/home/setuc/.dotfiles/bash/functions/prompt/update_prompt.sh`:

```sh
# ~/functions/prompt/update_prompt.sh  
  
# Function to update Oh My Posh prompt with environment info  
update_prompt() {  
    if [ -n "$CONDA_DEFAULT_ENV" ]; then  
        export POSH_PYTHON_ENV="conda:$CONDA_DEFAULT_ENV"  
    elif [ -n "$VIRTUAL_ENV" ]; then  
        export POSH_PYTHON_ENV="venv:$(basename $VIRTUAL_ENV)"  
    else  
        unset POSH_PYTHON_ENV  
    fi  
}  

```

`/home/setuc/.dotfiles/bash/functions/utilities/download_verify_install.sh`:

```sh
# ~/functions/utilities/download_verify_install.sh  
  
# Function to download, verify hash, and install  
download_verify_install() {  
    if [ "$#" -lt 2 ]; then  
        echo "Usage: download_verify_install <URL> <expected_hash> [install_command]"  
        return 1  
    fi  
  
    local url="$1"  
    local expected_hash="$2"  
    local install_command="${3:-}"  
    local filename=$(basename "$url")  
  
    # Download the file  
    wget "$url" -O "$filename"  
  
    # Compute the SHA256 hash of the downloaded file  
    local computed_hash=$(sha256sum "$filename" | awk '{print $1}')  
  
    # Compare the hashes  
    if [ "$computed_hash" = "$expected_hash" ]; then  
        echo -e "\e[32mHash verification successful.\e[0m"  
        if [ -n "$install_command" ]; then  
            echo "Proceeding with installation."  
            # Execute the install command  
            eval "$install_command"  
        else  
            echo "No install command provided. Skipping installation."  
        fi  
    else  
        echo -e "\e[31mHash verification failed. Aborting installation.\e[0m"  
        echo "Expected hash: $expected_hash"  
        echo "Computed hash: $computed_hash"  
        # Remove the downloaded file  
        rm "$filename"  
        return 1  
    fi  
}  

```

`/home/setuc/.dotfiles/bash/functions/conda/create_conda_env.sh`:

```sh
# ~/functions/conda/create_conda_env.sh  
  
# Function to create a Conda environment  
create_conda_env() {  
    if [ $# -lt 2 ]; then  
        echo "Usage: create_conda_env <env_name> <python_version> [packages/file]"  
        return 1  
    fi  
  
    env_name="$1"  
    python_version="$2"  
    shift 2  
  
    # Create base environment with specified Python version  
    conda create -n "$env_name" python="$python_version" -y  
  
    # Activate the new environment  
    conda activate "$env_name"  
  
    if [ $# -gt 0 ]; then  
        if [ -f "$1" ]; then  
            # Check if it's a YAML file  
            if [[ "$1" == *.yml ]] || [[ "$1" == *.yaml ]]; then  
                conda env update --file "$1"  
            # Check if it's a requirements.txt file  
            elif [[ "$1" == *requirements.txt ]]; then  
                pip install -r "$1"  
            else  
                echo "Unrecognized file format. Please use .yml, .yaml, or requirements.txt"  
            fi  
        else  
            # Install specified packages  
            conda install "$@" -y  
        fi  
    fi  
  
    echo "Environment '$env_name' created with Python $python_version"  
    conda list  
}  

```

`/home/setuc/.dotfiles/bash/completions/git-completion.bash`:

```bash
# Downloaded and place the content from:  
# https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash  
# bash/zsh completion support for core Git.
#
# Copyright (C) 2006,2007 Shawn O. Pearce <spearce@spearce.org>
# Conceptually based on gitcompletion (http://gitweb.hawaga.org.uk/).
# Distributed under the GNU General Public License, version 2.0.
#
# The contained completion routines provide support for completing:
#
#    *) local and remote branch names
#    *) local and remote tag names
#    *) .git/remotes file names
#    *) git 'subcommands'
#    *) git email aliases for git-send-email
#    *) tree paths within 'ref:path/to/file' expressions
#    *) file paths within current working directory and index
#    *) common --long-options
#
# To use these routines:
#
#    1) Copy this file to somewhere (e.g. ~/.git-completion.bash).
#    2) Add the following line to your .bashrc/.zshrc:
#        source ~/.git-completion.bash
#    3) Consider changing your PS1 to also show the current branch,
#       see git-prompt.sh for details.
#
# If you use complex aliases of form '!f() { ... }; f', you can use the null
# command ':' as the first command in the function body to declare the desired
# completion style.  For example '!f() { : git commit ; ... }; f' will
# tell the completion to use commit completion.  This also works with aliases
# of form "!sh -c '...'".  For example, "!sh -c ': git commit ; ... '".
# Note that "git" is optional --- '!f() { : commit; ...}; f' would complete
# just like the 'git commit' command.
#
# To add completion for git subcommands that are implemented in external
# scripts, define a function of the form '_git_${subcommand}' while replacing
# all dashes with underscores, and the main git completion will make use of it.
# For example, to add completion for 'git do-stuff' (which could e.g. live
# in /usr/bin/git-do-stuff), name the completion function '_git_do_stuff'.
# See _git_show, _git_bisect etc. below for more examples.
#
# If you have a shell command that is not part of git (and is not called as a
# git subcommand), but you would still like git-style completion for it, use
# __git_complete. For example, to use the same completion as for 'git log' also
# for the 'gl' command:
#
#   __git_complete gl git_log
#
# Or if the 'gk' command should be completed the same as 'gitk':
#
#   __git_complete gk gitk
#
# The second parameter of __git_complete gives the completion function; it is
# resolved as a function named "$2", or "__$2_main", or "_$2" in that order.
# In the examples above, the actual functions used for completion will be
# _git_log and __gitk_main.
#
# Compatible with bash 3.2.57.
#
# You can set the following environment variables to influence the behavior of
# the completion routines:
#
#   GIT_COMPLETION_CHECKOUT_NO_GUESS
#
#     When set to "1", do not include "DWIM" suggestions in git-checkout
#     and git-switch completion (e.g., completing "foo" when "origin/foo"
#     exists).
#
#   GIT_COMPLETION_SHOW_ALL_COMMANDS
#
#     When set to "1" suggest all commands, including plumbing commands
#     which are hidden by default (e.g. "cat-file" on "git ca<TAB>").
#
#   GIT_COMPLETION_SHOW_ALL
#
#     When set to "1" suggest all options, including options which are
#     typically hidden (e.g. '--allow-empty' for 'git commit').
#
#   GIT_COMPLETION_IGNORE_CASE
#
#     When set, uses for-each-ref '--ignore-case' to find refs that match
#     case insensitively, even on systems with case sensitive file systems
#     (e.g., completing tag name "FOO" on "git checkout f<TAB>").

case "$COMP_WORDBREAKS" in
*:*) : great ;;
*)   COMP_WORDBREAKS="$COMP_WORDBREAKS:"
esac

# Discovers the path to the git repository taking any '--git-dir=<path>' and
# '-C <path>' options into account and stores it in the $__git_repo_path
# variable.
__git_find_repo_path ()
{
	if [ -n "${__git_repo_path-}" ]; then
		# we already know where it is
		return
	fi

	if [ -n "${__git_C_args-}" ]; then
		__git_repo_path="$(git "${__git_C_args[@]}" \
			${__git_dir:+--git-dir="$__git_dir"} \
			rev-parse --absolute-git-dir 2>/dev/null)"
	elif [ -n "${__git_dir-}" ]; then
		test -d "$__git_dir" &&
		__git_repo_path="$__git_dir"
	elif [ -n "${GIT_DIR-}" ]; then
		test -d "$GIT_DIR" &&
		__git_repo_path="$GIT_DIR"
	elif [ -d .git ]; then
		__git_repo_path=.git
	else
		__git_repo_path="$(git rev-parse --git-dir 2>/dev/null)"
	fi
}

# Deprecated: use __git_find_repo_path() and $__git_repo_path instead
# __gitdir accepts 0 or 1 arguments (i.e., location)
# returns location of .git repo
__gitdir ()
{
	if [ -z "${1-}" ]; then
		__git_find_repo_path || return 1
		echo "$__git_repo_path"
	elif [ -d "$1/.git" ]; then
		echo "$1/.git"
	else
		echo "$1"
	fi
}

# Runs git with all the options given as argument, respecting any
# '--git-dir=<path>' and '-C <path>' options present on the command line
__git ()
{
	git ${__git_C_args:+"${__git_C_args[@]}"} \
		${__git_dir:+--git-dir="$__git_dir"} "$@" 2>/dev/null
}

# Helper function to read the first line of a file into a variable.
# __git_eread requires 2 arguments, the file path and the name of the
# variable, in that order.
#
# This is taken from git-prompt.sh.
__git_eread ()
{
	test -r "$1" && IFS=$'\r\n' read -r "$2" <"$1"
}

# Runs git in $__git_repo_path to determine whether a pseudoref exists.
# 1: The pseudo-ref to search
__git_pseudoref_exists ()
{
	local ref=$1
	local head

	__git_find_repo_path

	# If the reftable is in use, we have to shell out to 'git rev-parse'
	# to determine whether the ref exists instead of looking directly in
	# the filesystem to determine whether the ref exists. Otherwise, use
	# Bash builtins since executing Git commands are expensive on some
	# platforms.
	if __git_eread "$__git_repo_path/HEAD" head; then
		if [ "$head" == "ref: refs/heads/.invalid" ]; then
			__git show-ref --exists "$ref"
			return $?
		fi
	fi

	[ -f "$__git_repo_path/$ref" ]
}

# Removes backslash escaping, single quotes and double quotes from a word,
# stores the result in the variable $dequoted_word.
# 1: The word to dequote.
__git_dequote ()
{
	local rest="$1" len ch

	dequoted_word=""

	while test -n "$rest"; do
		len=${#dequoted_word}
		dequoted_word="$dequoted_word${rest%%[\\\'\"]*}"
		rest="${rest:$((${#dequoted_word}-$len))}"

		case "${rest:0:1}" in
		\\)
			ch="${rest:1:1}"
			case "$ch" in
			$'\n')
				;;
			*)
				dequoted_word="$dequoted_word$ch"
				;;
			esac
			rest="${rest:2}"
			;;
		\')
			rest="${rest:1}"
			len=${#dequoted_word}
			dequoted_word="$dequoted_word${rest%%\'*}"
			rest="${rest:$((${#dequoted_word}-$len+1))}"
			;;
		\")
			rest="${rest:1}"
			while test -n "$rest" ; do
				len=${#dequoted_word}
				dequoted_word="$dequoted_word${rest%%[\\\"]*}"
				rest="${rest:$((${#dequoted_word}-$len))}"
				case "${rest:0:1}" in
				\\)
					ch="${rest:1:1}"
					case "$ch" in
					\"|\\|\$|\`)
						dequoted_word="$dequoted_word$ch"
						;;
					$'\n')
						;;
					*)
						dequoted_word="$dequoted_word\\$ch"
						;;
					esac
					rest="${rest:2}"
					;;
				\")
					rest="${rest:1}"
					break
					;;
				esac
			done
			;;
		esac
	done
}

# The following function is based on code from:
#
#   bash_completion - programmable completion functions for bash 3.2+
#
#   Copyright © 2006-2008, Ian Macdonald <ian@caliban.org>
#             © 2009-2010, Bash Completion Maintainers
#                     <bash-completion-devel@lists.alioth.debian.org>
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2, or (at your option)
#   any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, see <http://www.gnu.org/licenses/>.
#
#   The latest version of this software can be obtained here:
#
#   http://bash-completion.alioth.debian.org/
#
#   RELEASE: 2.x

# This function can be used to access a tokenized list of words
# on the command line:
#
#	__git_reassemble_comp_words_by_ref '=:'
#	if test "${words_[cword_-1]}" = -w
#	then
#		...
#	fi
#
# The argument should be a collection of characters from the list of
# word completion separators (COMP_WORDBREAKS) to treat as ordinary
# characters.
#
# This is roughly equivalent to going back in time and setting
# COMP_WORDBREAKS to exclude those characters.  The intent is to
# make option types like --date=<type> and <rev>:<path> easy to
# recognize by treating each shell word as a single token.
#
# It is best not to set COMP_WORDBREAKS directly because the value is
# shared with other completion scripts.  By the time the completion
# function gets called, COMP_WORDS has already been populated so local
# changes to COMP_WORDBREAKS have no effect.
#
# Output: words_, cword_, cur_.

__git_reassemble_comp_words_by_ref()
{
	local exclude i j first
	# Which word separators to exclude?
	exclude="${1//[^$COMP_WORDBREAKS]}"
	cword_=$COMP_CWORD
	if [ -z "$exclude" ]; then
		words_=("${COMP_WORDS[@]}")
		return
	fi
	# List of word completion separators has shrunk;
	# re-assemble words to complete.
	for ((i=0, j=0; i < ${#COMP_WORDS[@]}; i++, j++)); do
		# Append each nonempty word consisting of just
		# word separator characters to the current word.
		first=t
		while
			[ $i -gt 0 ] &&
			[ -n "${COMP_WORDS[$i]}" ] &&
			# word consists of excluded word separators
			[ "${COMP_WORDS[$i]//[^$exclude]}" = "${COMP_WORDS[$i]}" ]
		do
			# Attach to the previous token,
			# unless the previous token is the command name.
			if [ $j -ge 2 ] && [ -n "$first" ]; then
				((j--))
			fi
			first=
			words_[$j]=${words_[j]}${COMP_WORDS[i]}
			if [ $i = $COMP_CWORD ]; then
				cword_=$j
			fi
			if (($i < ${#COMP_WORDS[@]} - 1)); then
				((i++))
			else
				# Done.
				return
			fi
		done
		words_[$j]=${words_[j]}${COMP_WORDS[i]}
		if [ $i = $COMP_CWORD ]; then
			cword_=$j
		fi
	done
}

if ! type _get_comp_words_by_ref >/dev/null 2>&1; then
_get_comp_words_by_ref ()
{
	local exclude cur_ words_ cword_
	if [ "$1" = "-n" ]; then
		exclude=$2
		shift 2
	fi
	__git_reassemble_comp_words_by_ref "$exclude"
	cur_=${words_[cword_]}
	while [ $# -gt 0 ]; do
		case "$1" in
		cur)
			cur=$cur_
			;;
		prev)
			prev=${words_[$cword_-1]}
			;;
		words)
			words=("${words_[@]}")
			;;
		cword)
			cword=$cword_
			;;
		esac
		shift
	done
}
fi

# Fills the COMPREPLY array with prefiltered words without any additional
# processing.
# Callers must take care of providing only words that match the current word
# to be completed and adding any prefix and/or suffix (trailing space!), if
# necessary.
# 1: List of newline-separated matching completion words, complete with
#    prefix and suffix.
__gitcomp_direct ()
{
	local IFS=$'\n'

	COMPREPLY=($1)
}

# Similar to __gitcomp_direct, but appends to COMPREPLY instead.
# Callers must take care of providing only words that match the current word
# to be completed and adding any prefix and/or suffix (trailing space!), if
# necessary.
# 1: List of newline-separated matching completion words, complete with
#    prefix and suffix.
__gitcomp_direct_append ()
{
	local IFS=$'\n'

	COMPREPLY+=($1)
}

__gitcompappend ()
{
	local x i=${#COMPREPLY[@]}
	for x in $1; do
		if [[ "$x" == "$3"* ]]; then
			COMPREPLY[i++]="$2$x$4"
		fi
	done
}

__gitcompadd ()
{
	COMPREPLY=()
	__gitcompappend "$@"
}

# Generates completion reply, appending a space to possible completion words,
# if necessary.
# It accepts 1 to 4 arguments:
# 1: List of possible completion words.
# 2: A prefix to be added to each possible completion word (optional).
# 3: Generate possible completion matches for this word (optional).
# 4: A suffix to be appended to each possible completion word (optional).
__gitcomp ()
{
	local cur_="${3-$cur}"

	case "$cur_" in
	*=)
		;;
	--no-*)
		local c i=0 IFS=$' \t\n'
		for c in $1; do
			if [[ $c == "--" ]]; then
				continue
			fi
			c="$c${4-}"
			if [[ $c == "$cur_"* ]]; then
				case $c in
				--*=|*.) ;;
				*) c="$c " ;;
				esac
				COMPREPLY[i++]="${2-}$c"
			fi
		done
		;;
	*)
		local c i=0 IFS=$' \t\n'
		for c in $1; do
			if [[ $c == "--" ]]; then
				c="--no-...${4-}"
				if [[ $c == "$cur_"* ]]; then
					COMPREPLY[i++]="${2-}$c "
				fi
				break
			fi
			c="$c${4-}"
			if [[ $c == "$cur_"* ]]; then
				case $c in
				*=|*.) ;;
				*) c="$c " ;;
				esac
				COMPREPLY[i++]="${2-}$c"
			fi
		done
		;;
	esac
}

# Clear the variables caching builtins' options when (re-)sourcing
# the completion script.
if [[ -n ${ZSH_VERSION-} ]]; then
	unset ${(M)${(k)parameters[@]}:#__gitcomp_builtin_*} 2>/dev/null
else
	unset $(compgen -v __gitcomp_builtin_)
fi

# This function is equivalent to
#
#    ___git_resolved_builtins=$(git xxx --git-completion-helper)
#
# except that the result of the execution is cached.
#
# Accept 1-3 arguments:
# 1: the git command to execute, this is also the cache key
#    (use "_" when the command contains spaces, e.g. "remote add"
#    becomes "remote_add")
# 2: extra options to be added on top (e.g. negative forms)
# 3: options to be excluded
__git_resolve_builtins ()
{
	local cmd="$1"
	local incl="${2-}"
	local excl="${3-}"

	local var=__gitcomp_builtin_"${cmd//-/_}"
	local options
	eval "options=\${$var-}"

	if [ -z "$options" ]; then
		local completion_helper
		if [ "${GIT_COMPLETION_SHOW_ALL-}" = "1" ]; then
			completion_helper="--git-completion-helper-all"
		else
			completion_helper="--git-completion-helper"
		fi
		# leading and trailing spaces are significant to make
		# option removal work correctly.
		options=" $incl $(__git ${cmd/_/ } $completion_helper) " || return

		for i in $excl; do
			options="${options/ $i / }"
		done
		eval "$var=\"$options\""
	fi

	___git_resolved_builtins="$options"
}

# This function is equivalent to
#
#    __gitcomp "$(git xxx --git-completion-helper) ..."
#
# except that the output is cached. Accept 1-3 arguments:
# 1: the git command to execute, this is also the cache key
#    (use "_" when the command contains spaces, e.g. "remote add"
#    becomes "remote_add")
# 2: extra options to be added on top (e.g. negative forms)
# 3: options to be excluded
__gitcomp_builtin ()
{
	__git_resolve_builtins "$1" "$2" "$3"

	__gitcomp "$___git_resolved_builtins"
}

# Variation of __gitcomp_nl () that appends to the existing list of
# completion candidates, COMPREPLY.
__gitcomp_nl_append ()
{
	local IFS=$'\n'
	__gitcompappend "$1" "${2-}" "${3-$cur}" "${4- }"
}

# Generates completion reply from newline-separated possible completion words
# by appending a space to all of them.
# It accepts 1 to 4 arguments:
# 1: List of possible completion words, separated by a single newline.
# 2: A prefix to be added to each possible completion word (optional).
# 3: Generate possible completion matches for this word (optional).
# 4: A suffix to be appended to each possible completion word instead of
#    the default space (optional).  If specified but empty, nothing is
#    appended.
__gitcomp_nl ()
{
	COMPREPLY=()
	__gitcomp_nl_append "$@"
}

# Fills the COMPREPLY array with prefiltered paths without any additional
# processing.
# Callers must take care of providing only paths that match the current path
# to be completed and adding any prefix path components, if necessary.
# 1: List of newline-separated matching paths, complete with all prefix
#    path components.
__gitcomp_file_direct ()
{
	local IFS=$'\n'

	COMPREPLY=($1)

	# use a hack to enable file mode in bash < 4
	compopt -o filenames +o nospace 2>/dev/null ||
	compgen -f /non-existing-dir/ >/dev/null ||
	true
}

# Generates completion reply with compgen from newline-separated possible
# completion filenames.
# It accepts 1 to 3 arguments:
# 1: List of possible completion filenames, separated by a single newline.
# 2: A directory prefix to be added to each possible completion filename
#    (optional).
# 3: Generate possible completion matches for this word (optional).
__gitcomp_file ()
{
	local IFS=$'\n'

	# XXX does not work when the directory prefix contains a tilde,
	# since tilde expansion is not applied.
	# This means that COMPREPLY will be empty and Bash default
	# completion will be used.
	__gitcompadd "$1" "${2-}" "${3-$cur}" ""

	# use a hack to enable file mode in bash < 4
	compopt -o filenames +o nospace 2>/dev/null ||
	compgen -f /non-existing-dir/ >/dev/null ||
	true
}

# Find the current subcommand for commands that follow the syntax:
#
#    git <command> <subcommand>
#
# 1: List of possible subcommands.
# 2: Optional subcommand to return when none is found.
__git_find_subcommand ()
{
	local subcommand subcommands="$1" default_subcommand="$2"

	for subcommand in $subcommands; do
		if [ "$subcommand" = "${words[__git_cmd_idx+1]}" ]; then
			echo $subcommand
			return
		fi
	done

	echo $default_subcommand
}

# Execute 'git ls-files', unless the --committable option is specified, in
# which case it runs 'git diff-index' to find out the files that can be
# committed.  It return paths relative to the directory specified in the first
# argument, and using the options specified in the second argument.
__git_ls_files_helper ()
{
	if [ "$2" = "--committable" ]; then
		__git -C "$1" -c core.quotePath=false diff-index \
			--name-only --relative HEAD -- "${3//\\/\\\\}*"
	else
		# NOTE: $2 is not quoted in order to support multiple options
		__git -C "$1" -c core.quotePath=false ls-files \
			--exclude-standard $2 -- "${3//\\/\\\\}*"
	fi
}


# __git_index_files accepts 1 or 2 arguments:
# 1: Options to pass to ls-files (required).
# 2: A directory path (optional).
#    If provided, only files within the specified directory are listed.
#    Sub directories are never recursed.  Path must have a trailing
#    slash.
# 3: List only paths matching this path component (optional).
__git_index_files ()
{
	local root="$2" match="$3"

	__git_ls_files_helper "$root" "$1" "${match:-?}" |
	awk -F / -v pfx="${2//\\/\\\\}" '{
		paths[$1] = 1
	}
	END {
		for (p in paths) {
			if (substr(p, 1, 1) != "\"") {
				# No special characters, easy!
				print pfx p
				continue
			}

			# The path is quoted.
			p = dequote(p)
			if (p == "")
				continue

			# Even when a directory name itself does not contain
			# any special characters, it will still be quoted if
			# any of its (stripped) trailing path components do.
			# Because of this we may have seen the same directory
			# both quoted and unquoted.
			if (p in paths)
				# We have seen the same directory unquoted,
				# skip it.
				continue
			else
				print pfx p
		}
	}
	function dequote(p,    bs_idx, out, esc, esc_idx, dec) {
		# Skip opening double quote.
		p = substr(p, 2)

		# Interpret backslash escape sequences.
		while ((bs_idx = index(p, "\\")) != 0) {
			out = out substr(p, 1, bs_idx - 1)
			esc = substr(p, bs_idx + 1, 1)
			p = substr(p, bs_idx + 2)

			if ((esc_idx = index("abtvfr\"\\", esc)) != 0) {
				# C-style one-character escape sequence.
				out = out substr("\a\b\t\v\f\r\"\\",
						 esc_idx, 1)
			} else if (esc == "n") {
				# Uh-oh, a newline character.
				# We cannot reliably put a pathname
				# containing a newline into COMPREPLY,
				# and the newline would create a mess.
				# Skip this path.
				return ""
			} else {
				# Must be a \nnn octal value, then.
				dec = esc             * 64 + \
				      substr(p, 1, 1) * 8  + \
				      substr(p, 2, 1)
				out = out sprintf("%c", dec)
				p = substr(p, 3)
			}
		}
		# Drop closing double quote, if there is one.
		# (There is not any if this is a directory, as it was
		# already stripped with the trailing path components.)
		if (substr(p, length(p), 1) == "\"")
			out = out substr(p, 1, length(p) - 1)
		else
			out = out p

		return out
	}'
}

# __git_complete_index_file requires 1 argument:
# 1: the options to pass to ls-file
#
# The exception is --committable, which finds the files appropriate commit.
__git_complete_index_file ()
{
	local dequoted_word pfx="" cur_

	__git_dequote "$cur"

	case "$dequoted_word" in
	?*/*)
		pfx="${dequoted_word%/*}/"
		cur_="${dequoted_word##*/}"
		;;
	*)
		cur_="$dequoted_word"
	esac

	__gitcomp_file_direct "$(__git_index_files "$1" "$pfx" "$cur_")"
}

# Lists branches from the local repository.
# 1: A prefix to be added to each listed branch (optional).
# 2: List only branches matching this word (optional; list all branches if
#    unset or empty).
# 3: A suffix to be appended to each listed branch (optional).
__git_heads ()
{
	local pfx="${1-}" cur_="${2-}" sfx="${3-}"

	__git for-each-ref --format="${pfx//\%/%%}%(refname:strip=2)$sfx" \
			${GIT_COMPLETION_IGNORE_CASE+--ignore-case} \
			"refs/heads/$cur_*" "refs/heads/$cur_*/**"
}

# Lists branches from remote repositories.
# 1: A prefix to be added to each listed branch (optional).
# 2: List only branches matching this word (optional; list all branches if
#    unset or empty).
# 3: A suffix to be appended to each listed branch (optional).
__git_remote_heads ()
{
	local pfx="${1-}" cur_="${2-}" sfx="${3-}"

	__git for-each-ref --format="${pfx//\%/%%}%(refname:strip=2)$sfx" \
			${GIT_COMPLETION_IGNORE_CASE+--ignore-case} \
			"refs/remotes/$cur_*" "refs/remotes/$cur_*/**"
}

# Lists tags from the local repository.
# Accepts the same positional parameters as __git_heads() above.
__git_tags ()
{
	local pfx="${1-}" cur_="${2-}" sfx="${3-}"

	__git for-each-ref --format="${pfx//\%/%%}%(refname:strip=2)$sfx" \
			${GIT_COMPLETION_IGNORE_CASE+--ignore-case} \
			"refs/tags/$cur_*" "refs/tags/$cur_*/**"
}

# List unique branches from refs/remotes used for 'git checkout' and 'git
# switch' tracking DWIMery.
# 1: A prefix to be added to each listed branch (optional)
# 2: List only branches matching this word (optional; list all branches if
#    unset or empty).
# 3: A suffix to be appended to each listed branch (optional).
__git_dwim_remote_heads ()
{
	local pfx="${1-}" cur_="${2-}" sfx="${3-}"
	local fer_pfx="${pfx//\%/%%}" # "escape" for-each-ref format specifiers

	# employ the heuristic used by git checkout and git switch
	# Try to find a remote branch that cur_es the completion word
	# but only output if the branch name is unique
	__git for-each-ref --format="$fer_pfx%(refname:strip=3)$sfx" \
		--sort="refname:strip=3" \
		${GIT_COMPLETION_IGNORE_CASE+--ignore-case} \
		"refs/remotes/*/$cur_*" "refs/remotes/*/$cur_*/**" | \
	uniq -u
}

# Lists refs from the local (by default) or from a remote repository.
# It accepts 0, 1 or 2 arguments:
# 1: The remote to list refs from (optional; ignored, if set but empty).
#    Can be the name of a configured remote, a path, or a URL.
# 2: In addition to local refs, list unique branches from refs/remotes/ for
#    'git checkout's tracking DWIMery (optional; ignored, if set but empty).
# 3: A prefix to be added to each listed ref (optional).
# 4: List only refs matching this word (optional; list all refs if unset or
#    empty).
# 5: A suffix to be appended to each listed ref (optional; ignored, if set
#    but empty).
#
# Use __git_complete_refs() instead.
__git_refs ()
{
	local i hash dir track="${2-}"
	local list_refs_from=path remote="${1-}"
	local format refs
	local pfx="${3-}" cur_="${4-$cur}" sfx="${5-}"
	local match="${4-}"
	local umatch="${4-}"
	local fer_pfx="${pfx//\%/%%}" # "escape" for-each-ref format specifiers

	__git_find_repo_path
	dir="$__git_repo_path"

	if [ -z "$remote" ]; then
		if [ -z "$dir" ]; then
			return
		fi
	else
		if __git_is_configured_remote "$remote"; then
			# configured remote takes precedence over a
			# local directory with the same name
			list_refs_from=remote
		elif [ -d "$remote/.git" ]; then
			dir="$remote/.git"
		elif [ -d "$remote" ]; then
			dir="$remote"
		else
			list_refs_from=url
		fi
	fi

	if test "${GIT_COMPLETION_IGNORE_CASE:+1}" = "1"
	then
		# uppercase with tr instead of ${match,^^} for bash 3.2 compatibility
		umatch=$(echo "$match" | tr a-z A-Z 2>/dev/null || echo "$match")
	fi

	if [ "$list_refs_from" = path ]; then
		if [[ "$cur_" == ^* ]]; then
			pfx="$pfx^"
			fer_pfx="$fer_pfx^"
			cur_=${cur_#^}
			match=${match#^}
			umatch=${umatch#^}
		fi
		case "$cur_" in
		refs|refs/*)
			format="refname"
			refs=("$match*" "$match*/**")
			track=""
			;;
		*)
			for i in HEAD FETCH_HEAD ORIG_HEAD MERGE_HEAD REBASE_HEAD CHERRY_PICK_HEAD REVERT_HEAD BISECT_HEAD AUTO_MERGE; do
				case "$i" in
				$match*|$umatch*)
					if [ -e "$dir/$i" ]; then
						echo "$pfx$i$sfx"
					fi
					;;
				esac
			done
			format="refname:strip=2"
			refs=("refs/tags/$match*" "refs/tags/$match*/**"
				"refs/heads/$match*" "refs/heads/$match*/**"
				"refs/remotes/$match*" "refs/remotes/$match*/**")
			;;
		esac
		__git_dir="$dir" __git for-each-ref --format="$fer_pfx%($format)$sfx" \
			${GIT_COMPLETION_IGNORE_CASE+--ignore-case} \
			"${refs[@]}"
		if [ -n "$track" ]; then
			__git_dwim_remote_heads "$pfx" "$match" "$sfx"
		fi
		return
	fi
	case "$cur_" in
	refs|refs/*)
		__git ls-remote "$remote" "$match*" | \
		while read -r hash i; do
			case "$i" in
			*^{}) ;;
			*) echo "$pfx$i$sfx" ;;
			esac
		done
		;;
	*)
		if [ "$list_refs_from" = remote ]; then
			case "HEAD" in
			$match*|$umatch*)	echo "${pfx}HEAD$sfx" ;;
			esac
			__git for-each-ref --format="$fer_pfx%(refname:strip=3)$sfx" \
				${GIT_COMPLETION_IGNORE_CASE+--ignore-case} \
				"refs/remotes/$remote/$match*" \
				"refs/remotes/$remote/$match*/**"
		else
			local query_symref
			case "HEAD" in
			$match*|$umatch*)	query_symref="HEAD" ;;
			esac
			__git ls-remote "$remote" $query_symref \
				"refs/tags/$match*" "refs/heads/$match*" \
				"refs/remotes/$match*" |
			while read -r hash i; do
				case "$i" in
				*^{})	;;
				refs/*)	echo "$pfx${i#refs/*/}$sfx" ;;
				*)	echo "$pfx$i$sfx" ;;  # symbolic refs
				esac
			done
		fi
		;;
	esac
}

# Completes refs, short and long, local and remote, symbolic and pseudo.
#
# Usage: __git_complete_refs [<option>]...
# --remote=<remote>: The remote to list refs from, can be the name of a
#                    configured remote, a path, or a URL.
# --dwim: List unique remote branches for 'git switch's tracking DWIMery.
# --pfx=<prefix>: A prefix to be added to each ref.
# --cur=<word>: The current ref to be completed.  Defaults to the current
#               word to be completed.
# --sfx=<suffix>: A suffix to be appended to each ref instead of the default
#                 space.
# --mode=<mode>: What set of refs to complete, one of 'refs' (the default) to
#                complete all refs, 'heads' to complete only branches, or
#                'remote-heads' to complete only remote branches. Note that
#                --remote is only compatible with --mode=refs.
__git_complete_refs ()
{
	local remote= dwim= pfx= cur_="$cur" sfx=" " mode="refs"

	while test $# != 0; do
		case "$1" in
		--remote=*)	remote="${1##--remote=}" ;;
		--dwim)		dwim="yes" ;;
		# --track is an old spelling of --dwim
		--track)	dwim="yes" ;;
		--pfx=*)	pfx="${1##--pfx=}" ;;
		--cur=*)	cur_="${1##--cur=}" ;;
		--sfx=*)	sfx="${1##--sfx=}" ;;
		--mode=*)	mode="${1##--mode=}" ;;
		*)		return 1 ;;
		esac
		shift
	done

	# complete references based on the specified mode
	case "$mode" in
		refs)
			__gitcomp_direct "$(__git_refs "$remote" "" "$pfx" "$cur_" "$sfx")" ;;
		heads)
			__gitcomp_direct "$(__git_heads "$pfx" "$cur_" "$sfx")" ;;
		remote-heads)
			__gitcomp_direct "$(__git_remote_heads "$pfx" "$cur_" "$sfx")" ;;
		*)
			return 1 ;;
	esac

	# Append DWIM remote branch names if requested
	if [ "$dwim" = "yes" ]; then
		__gitcomp_direct_append "$(__git_dwim_remote_heads "$pfx" "$cur_" "$sfx")"
	fi
}

# __git_refs2 requires 1 argument (to pass to __git_refs)
# Deprecated: use __git_complete_fetch_refspecs() instead.
__git_refs2 ()
{
	local i
	for i in $(__git_refs "$1"); do
		echo "$i:$i"
	done
}

# Completes refspecs for fetching from a remote repository.
# 1: The remote repository.
# 2: A prefix to be added to each listed refspec (optional).
# 3: The ref to be completed as a refspec instead of the current word to be
#    completed (optional)
# 4: A suffix to be appended to each listed refspec instead of the default
#    space (optional).
__git_complete_fetch_refspecs ()
{
	local i remote="$1" pfx="${2-}" cur_="${3-$cur}" sfx="${4- }"

	__gitcomp_direct "$(
		for i in $(__git_refs "$remote" "" "" "$cur_") ; do
			echo "$pfx$i:$i$sfx"
		done
		)"
}

# __git_refs_remotes requires 1 argument (to pass to ls-remote)
__git_refs_remotes ()
{
	local i hash
	__git ls-remote "$1" 'refs/heads/*' | \
	while read -r hash i; do
		echo "$i:refs/remotes/$1/${i#refs/heads/}"
	done
}

__git_remotes ()
{
	__git_find_repo_path
	test -d "$__git_repo_path/remotes" && ls -1 "$__git_repo_path/remotes"
	__git remote
}

# Returns true if $1 matches the name of a configured remote, false otherwise.
__git_is_configured_remote ()
{
	local remote
	for remote in $(__git_remotes); do
		if [ "$remote" = "$1" ]; then
			return 0
		fi
	done
	return 1
}

__git_list_merge_strategies ()
{
	LANG=C LC_ALL=C git merge -s help 2>&1 |
	sed -n -e '/[Aa]vailable strategies are: /,/^$/{
		s/\.$//
		s/.*://
		s/^[ 	]*//
		s/[ 	]*$//
		p
	}'
}

__git_merge_strategies=
# 'git merge -s help' (and thus detection of the merge strategy
# list) fails, unfortunately, if run outside of any git working
# tree.  __git_merge_strategies is set to the empty string in
# that case, and the detection will be repeated the next time it
# is needed.
__git_compute_merge_strategies ()
{
	test -n "$__git_merge_strategies" ||
	__git_merge_strategies=$(__git_list_merge_strategies)
}

__git_merge_strategy_options="ours theirs subtree subtree= patience
	histogram diff-algorithm= ignore-space-change ignore-all-space
	ignore-space-at-eol renormalize no-renormalize no-renames
	find-renames find-renames= rename-threshold="

__git_complete_revlist_file ()
{
	local dequoted_word pfx ls ref cur_="$cur"
	case "$cur_" in
	*..?*:*)
		return
		;;
	?*:*)
		ref="${cur_%%:*}"
		cur_="${cur_#*:}"

		__git_dequote "$cur_"

		case "$dequoted_word" in
		?*/*)
			pfx="${dequoted_word%/*}"
			cur_="${dequoted_word##*/}"
			ls="$ref:$pfx"
			pfx="$pfx/"
			;;
		*)
			cur_="$dequoted_word"
			ls="$ref"
			;;
		esac

		case "$COMP_WORDBREAKS" in
		*:*) : great ;;
		*)   pfx="$ref:$pfx" ;;
		esac

		__gitcomp_file "$(__git ls-tree "$ls" \
				| sed 's/^.*	//
				       s/$//')" \
			"$pfx" "$cur_"
		;;
	*...*)
		pfx="${cur_%...*}..."
		cur_="${cur_#*...}"
		__git_complete_refs --pfx="$pfx" --cur="$cur_"
		;;
	*..*)
		pfx="${cur_%..*}.."
		cur_="${cur_#*..}"
		__git_complete_refs --pfx="$pfx" --cur="$cur_"
		;;
	*)
		__git_complete_refs
		;;
	esac
}

__git_complete_file ()
{
	__git_complete_revlist_file
}

__git_complete_revlist ()
{
	__git_complete_revlist_file
}

__git_complete_remote_or_refspec ()
{
	local cur_="$cur" cmd="${words[__git_cmd_idx]}"
	local i c=$((__git_cmd_idx+1)) remote="" pfx="" lhs=1 no_complete_refspec=0
	if [ "$cmd" = "remote" ]; then
		((c++))
	fi
	while [ $c -lt $cword ]; do
		i="${words[c]}"
		case "$i" in
		--mirror) [ "$cmd" = "push" ] && no_complete_refspec=1 ;;
		-d|--delete) [ "$cmd" = "push" ] && lhs=0 ;;
		--all)
			case "$cmd" in
			push) no_complete_refspec=1 ;;
			fetch)
				return
				;;
			*) ;;
			esac
			;;
		--multiple) no_complete_refspec=1; break ;;
		-*) ;;
		*) remote="$i"; break ;;
		esac
		((c++))
	done
	if [ -z "$remote" ]; then
		__gitcomp_nl "$(__git_remotes)"
		return
	fi
	if [ $no_complete_refspec = 1 ]; then
		return
	fi
	[ "$remote" = "." ] && remote=
	case "$cur_" in
	*:*)
		case "$COMP_WORDBREAKS" in
		*:*) : great ;;
		*)   pfx="${cur_%%:*}:" ;;
		esac
		cur_="${cur_#*:}"
		lhs=0
		;;
	+*)
		pfx="+"
		cur_="${cur_#+}"
		;;
	esac
	case "$cmd" in
	fetch)
		if [ $lhs = 1 ]; then
			__git_complete_fetch_refspecs "$remote" "$pfx" "$cur_"
		else
			__git_complete_refs --pfx="$pfx" --cur="$cur_"
		fi
		;;
	pull|remote)
		if [ $lhs = 1 ]; then
			__git_complete_refs --remote="$remote" --pfx="$pfx" --cur="$cur_"
		else
			__git_complete_refs --pfx="$pfx" --cur="$cur_"
		fi
		;;
	push)
		if [ $lhs = 1 ]; then
			__git_complete_refs --pfx="$pfx" --cur="$cur_"
		else
			__git_complete_refs --remote="$remote" --pfx="$pfx" --cur="$cur_"
		fi
		;;
	esac
}

__git_complete_strategy ()
{
	__git_compute_merge_strategies
	case "$prev" in
	-s|--strategy)
		__gitcomp "$__git_merge_strategies"
		return 0
		;;
	-X)
		__gitcomp "$__git_merge_strategy_options"
		return 0
		;;
	esac
	case "$cur" in
	--strategy=*)
		__gitcomp "$__git_merge_strategies" "" "${cur##--strategy=}"
		return 0
		;;
	--strategy-option=*)
		__gitcomp "$__git_merge_strategy_options" "" "${cur##--strategy-option=}"
		return 0
		;;
	esac
	return 1
}

__git_all_commands=
__git_compute_all_commands ()
{
	test -n "$__git_all_commands" ||
	__git_all_commands=$(__git --list-cmds=main,others,alias,nohelpers)
}

# Lists all set config variables starting with the given section prefix,
# with the prefix removed.
__git_get_config_variables ()
{
	local section="$1" i IFS=$'\n'
	for i in $(__git config --name-only --get-regexp "^$section\..*"); do
		echo "${i#$section.}"
	done
}

__git_pretty_aliases ()
{
	__git_get_config_variables "pretty"
}

# __git_aliased_command requires 1 argument
__git_aliased_command ()
{
	local cur=$1 last list= word cmdline

	while [[ -n "$cur" ]]; do
		if [[ "$list" == *" $cur "* ]]; then
			# loop detected
			return
		fi

		cmdline=$(__git config --get "alias.$cur")
		list=" $cur $list"
		last=$cur
		cur=

		for word in $cmdline; do
			case "$word" in
			\!gitk|gitk)
				cur="gitk"
				break
				;;
			\!*)	: shell command alias ;;
			-*)	: option ;;
			*=*)	: setting env ;;
			git)	: git itself ;;
			\(\))   : skip parens of shell function definition ;;
			{)	: skip start of shell helper function ;;
			:)	: skip null command ;;
			\'*)	: skip opening quote after sh -c ;;
			*)
				cur="${word%;}"
				break
			esac
		done
	done

	cur=$last
	if [[ "$cur" != "$1" ]]; then
		echo "$cur"
	fi
}

# Check whether one of the given words is present on the command line,
# and print the first word found.
#
# Usage: __git_find_on_cmdline [<option>]... "<wordlist>"
# --show-idx: Optionally show the index of the found word in the $words array.
__git_find_on_cmdline ()
{
	local word c="$__git_cmd_idx" show_idx

	while test $# -gt 1; do
		case "$1" in
		--show-idx)	show_idx=y ;;
		*)		return 1 ;;
		esac
		shift
	done
	local wordlist="$1"

	while [ $c -lt $cword ]; do
		for word in $wordlist; do
			if [ "$word" = "${words[c]}" ]; then
				if [ -n "${show_idx-}" ]; then
					echo "$c $word"
				else
					echo "$word"
				fi
				return
			fi
		done
		((c++))
	done
}

# Similar to __git_find_on_cmdline, except that it loops backwards and thus
# prints the *last* word found. Useful for finding which of two options that
# supersede each other came last, such as "--guess" and "--no-guess".
#
# Usage: __git_find_last_on_cmdline [<option>]... "<wordlist>"
# --show-idx: Optionally show the index of the found word in the $words array.
__git_find_last_on_cmdline ()
{
	local word c=$cword show_idx

	while test $# -gt 1; do
		case "$1" in
		--show-idx)	show_idx=y ;;
		*)		return 1 ;;
		esac
		shift
	done
	local wordlist="$1"

	while [ $c -gt "$__git_cmd_idx" ]; do
		((c--))
		for word in $wordlist; do
			if [ "$word" = "${words[c]}" ]; then
				if [ -n "$show_idx" ]; then
					echo "$c $word"
				else
					echo "$word"
				fi
				return
			fi
		done
	done
}

# Echo the value of an option set on the command line or config
#
# $1: short option name
# $2: long option name including =
# $3: list of possible values
# $4: config string (optional)
#
# example:
# result="$(__git_get_option_value "-d" "--do-something=" \
#     "yes no" "core.doSomething")"
#
# result is then either empty (no option set) or "yes" or "no"
#
# __git_get_option_value requires 3 arguments
__git_get_option_value ()
{
	local c short_opt long_opt val
	local result= values config_key word

	short_opt="$1"
	long_opt="$2"
	values="$3"
	config_key="$4"

	((c = $cword - 1))
	while [ $c -ge 0 ]; do
		word="${words[c]}"
		for val in $values; do
			if [ "$short_opt$val" = "$word" ] ||
			   [ "$long_opt$val"  = "$word" ]; then
				result="$val"
				break 2
			fi
		done
		((c--))
	done

	if [ -n "$config_key" ] && [ -z "$result" ]; then
		result="$(__git config "$config_key")"
	fi

	echo "$result"
}

__git_has_doubledash ()
{
	local c=1
	while [ $c -lt $cword ]; do
		if [ "--" = "${words[c]}" ]; then
			return 0
		fi
		((c++))
	done
	return 1
}

# Try to count non option arguments passed on the command line for the
# specified git command.
# When options are used, it is necessary to use the special -- option to
# tell the implementation were non option arguments begin.
# XXX this can not be improved, since options can appear everywhere, as
# an example:
#	git mv x -n y
#
# __git_count_arguments requires 1 argument: the git command executed.
__git_count_arguments ()
{
	local word i c=0

	# Skip "git" (first argument)
	for ((i=$__git_cmd_idx; i < ${#words[@]}; i++)); do
		word="${words[i]}"

		case "$word" in
			--)
				# Good; we can assume that the following are only non
				# option arguments.
				((c = 0))
				;;
			"$1")
				# Skip the specified git command and discard git
				# main options
				((c = 0))
				;;
			?*)
				((c++))
				;;
		esac
	done

	printf "%d" $c
}

__git_whitespacelist="nowarn warn error error-all fix"
__git_patchformat="mbox stgit stgit-series hg mboxrd"
__git_showcurrentpatch="diff raw"
__git_am_inprogress_options="--skip --continue --resolved --abort --quit --show-current-patch"
__git_quoted_cr="nowarn warn strip"

_git_am ()
{
	__git_find_repo_path
	if [ -d "$__git_repo_path"/rebase-apply ]; then
		__gitcomp "$__git_am_inprogress_options"
		return
	fi
	case "$cur" in
	--whitespace=*)
		__gitcomp "$__git_whitespacelist" "" "${cur##--whitespace=}"
		return
		;;
	--patch-format=*)
		__gitcomp "$__git_patchformat" "" "${cur##--patch-format=}"
		return
		;;
	--show-current-patch=*)
		__gitcomp "$__git_showcurrentpatch" "" "${cur##--show-current-patch=}"
		return
		;;
	--quoted-cr=*)
		__gitcomp "$__git_quoted_cr" "" "${cur##--quoted-cr=}"
		return
		;;
	--*)
		__gitcomp_builtin am "" \
			"$__git_am_inprogress_options"
		return
	esac
}

_git_apply ()
{
	case "$cur" in
	--whitespace=*)
		__gitcomp "$__git_whitespacelist" "" "${cur##--whitespace=}"
		return
		;;
	--*)
		__gitcomp_builtin apply
		return
	esac
}

_git_add ()
{
	case "$cur" in
	--chmod=*)
		__gitcomp "+x -x" "" "${cur##--chmod=}"
		return
		;;
	--*)
		__gitcomp_builtin add
		return
	esac

	local complete_opt="--others --modified --directory --no-empty-directory"
	if test -n "$(__git_find_on_cmdline "-u --update")"
	then
		complete_opt="--modified"
	fi
	__git_complete_index_file "$complete_opt"
}

_git_archive ()
{
	case "$cur" in
	--format=*)
		__gitcomp "$(git archive --list)" "" "${cur##--format=}"
		return
		;;
	--remote=*)
		__gitcomp_nl "$(__git_remotes)" "" "${cur##--remote=}"
		return
		;;
	--*)
		__gitcomp_builtin archive "--format= --list --verbose --prefix= --worktree-attributes"
		return
		;;
	esac
	__git_complete_file
}

_git_bisect ()
{
	__git_has_doubledash && return

	__git_find_repo_path

	# If a bisection is in progress get the terms being used.
	local term_bad term_good
	if [ -f "$__git_repo_path"/BISECT_TERMS ]; then
		term_bad=$(__git bisect terms --term-bad)
		term_good=$(__git bisect terms --term-good)
	fi

	# We will complete any custom terms, but still always complete the
	# more usual bad/new/good/old because git bisect gives a good error
	# message if these are given when not in use, and that's better than
	# silent refusal to complete if the user is confused.
	#
	# We want to recognize 'view' but not complete it, because it overlaps
	# with 'visualize' too much and is just an alias for it.
	#
	local completable_subcommands="start bad new $term_bad good old $term_good terms skip reset visualize replay log run help"
	local all_subcommands="$completable_subcommands view"

	local subcommand="$(__git_find_on_cmdline "$all_subcommands")"

	if [ -z "$subcommand" ]; then
		__git_find_repo_path
		if [ -f "$__git_repo_path"/BISECT_START ]; then
			__gitcomp "$completable_subcommands"
		else
			__gitcomp "replay start"
		fi
		return
	fi

	case "$subcommand" in
	start)
		case "$cur" in
		--*)
			__gitcomp "--first-parent --no-checkout --term-new --term-bad --term-old --term-good"
			return
			;;
		*)
			__git_complete_refs
			;;
		esac
		;;
	terms)
		__gitcomp "--term-good --term-old --term-bad --term-new"
		return
		;;
	visualize|view)
		__git_complete_log_opts
		return
		;;
	bad|new|"$term_bad"|good|old|"$term_good"|reset|skip)
		__git_complete_refs
		;;
	*)
		;;
	esac
}

__git_ref_fieldlist="refname objecttype objectsize objectname upstream push HEAD symref"

_git_branch ()
{
	local i c="$__git_cmd_idx" only_local_ref="n" has_r="n"

	while [ $c -lt $cword ]; do
		i="${words[c]}"
		case "$i" in
		-d|-D|--delete|-m|-M|--move|-c|-C|--copy)
			only_local_ref="y" ;;
		-r|--remotes)
			has_r="y" ;;
		esac
		((c++))
	done

	case "$cur" in
	--set-upstream-to=*)
		__git_complete_refs --cur="${cur##--set-upstream-to=}"
		;;
	--*)
		__gitcomp_builtin branch
		;;
	*)
		if [ $only_local_ref = "y" -a $has_r = "n" ]; then
			__gitcomp_direct "$(__git_heads "" "$cur" " ")"
		else
			__git_complete_refs
		fi
		;;
	esac
}

_git_bundle ()
{
	local cmd="${words[__git_cmd_idx+1]}"
	case "$cword" in
	$((__git_cmd_idx+1)))
		__gitcomp "create list-heads verify unbundle"
		;;
	$((__git_cmd_idx+2)))
		# looking for a file
		;;
	*)
		case "$cmd" in
			create)
				__git_complete_revlist
			;;
		esac
		;;
	esac
}

# Helper function to decide whether or not we should enable DWIM logic for
# git-switch and git-checkout.
#
# To decide between the following rules in decreasing priority order:
# - the last provided of "--guess" or "--no-guess" explicitly enable or
#   disable completion of DWIM logic respectively.
# - If checkout.guess is false, disable completion of DWIM logic.
# - If the --no-track option is provided, take this as a hint to disable the
#   DWIM completion logic
# - If GIT_COMPLETION_CHECKOUT_NO_GUESS is set, disable the DWIM completion
#   logic, as requested by the user.
# - Enable DWIM logic otherwise.
#
__git_checkout_default_dwim_mode ()
{
	local last_option dwim_opt="--dwim"

	if [ "${GIT_COMPLETION_CHECKOUT_NO_GUESS-}" = "1" ]; then
		dwim_opt=""
	fi

	# --no-track disables DWIM, but with lower priority than
	# --guess/--no-guess/checkout.guess
	if [ -n "$(__git_find_on_cmdline "--no-track")" ]; then
		dwim_opt=""
	fi

	# checkout.guess = false disables DWIM, but with lower priority than
	# --guess/--no-guess
	if [ "$(__git config --type=bool checkout.guess)" = "false" ]; then
		dwim_opt=""
	fi

	# Find the last provided --guess or --no-guess
	last_option="$(__git_find_last_on_cmdline "--guess --no-guess")"
	case "$last_option" in
		--guess)
			dwim_opt="--dwim"
			;;
		--no-guess)
			dwim_opt=""
			;;
	esac

	echo "$dwim_opt"
}

_git_checkout ()
{
	__git_has_doubledash && return

	local dwim_opt="$(__git_checkout_default_dwim_mode)"

	case "$prev" in
	-b|-B|--orphan)
		# Complete local branches (and DWIM branch
		# remote branch names) for an option argument
		# specifying a new branch name. This is for
		# convenience, assuming new branches are
		# possibly based on pre-existing branch names.
		__git_complete_refs $dwim_opt --mode="heads"
		return
		;;
	*)
		;;
	esac

	case "$cur" in
	--conflict=*)
		__gitcomp "diff3 merge zdiff3" "" "${cur##--conflict=}"
		;;
	--*)
		__gitcomp_builtin checkout
		;;
	*)
		# At this point, we've already handled special completion for
		# the arguments to -b/-B, and --orphan. There are 3 main
		# things left we can possibly complete:
		# 1) a start-point for -b/-B, -d/--detach, or --orphan
		# 2) a remote head, for --track
		# 3) an arbitrary reference, possibly including DWIM names
		#

		if [ -n "$(__git_find_on_cmdline "-b -B -d --detach --orphan")" ]; then
			__git_complete_refs --mode="refs"
		elif [ -n "$(__git_find_on_cmdline "-t --track")" ]; then
			__git_complete_refs --mode="remote-heads"
		else
			__git_complete_refs $dwim_opt --mode="refs"
		fi
		;;
	esac
}

__git_sequencer_inprogress_options="--continue --quit --abort --skip"

__git_cherry_pick_inprogress_options=$__git_sequencer_inprogress_options

_git_cherry_pick ()
{
	if __git_pseudoref_exists CHERRY_PICK_HEAD; then
		__gitcomp "$__git_cherry_pick_inprogress_options"
		return
	fi

	__git_complete_strategy && return

	case "$cur" in
	--*)
		__gitcomp_builtin cherry-pick "" \
			"$__git_cherry_pick_inprogress_options"
		;;
	*)
		__git_complete_refs
		;;
	esac
}

_git_clean ()
{
	case "$cur" in
	--*)
		__gitcomp_builtin clean
		return
		;;
	esac

	# XXX should we check for -x option ?
	__git_complete_index_file "--others --directory"
}

_git_clone ()
{
	case "$prev" in
	-c|--config)
		__git_complete_config_variable_name_and_value
		return
		;;
	esac
	case "$cur" in
	--config=*)
		__git_complete_config_variable_name_and_value \
			--cur="${cur##--config=}"
		return
		;;
	--*)
		__gitcomp_builtin clone
		return
		;;
	esac
}

__git_untracked_file_modes="all no normal"

__git_trailer_tokens ()
{
	__git config --name-only --get-regexp '^trailer\..*\.key$' | cut -d. -f 2- | rev | cut -d. -f2- | rev
}

_git_commit ()
{
	case "$prev" in
	-c|-C)
		__git_complete_refs
		return
		;;
	esac

	case "$cur" in
	--cleanup=*)
		__gitcomp "default scissors strip verbatim whitespace
			" "" "${cur##--cleanup=}"
		return
		;;
	--reuse-message=*|--reedit-message=*|\
	--fixup=*|--squash=*)
		__git_complete_refs --cur="${cur#*=}"
		return
		;;
	--untracked-files=*)
		__gitcomp "$__git_untracked_file_modes" "" "${cur##--untracked-files=}"
		return
		;;
	--trailer=*)
		__gitcomp_nl "$(__git_trailer_tokens)" "" "${cur##--trailer=}" ":"
		return
		;;
	--*)
		__gitcomp_builtin commit
		return
	esac

	if __git rev-parse --verify --quiet HEAD >/dev/null; then
		__git_complete_index_file "--committable"
	else
		# This is the first commit
		__git_complete_index_file "--cached"
	fi
}

_git_describe ()
{
	case "$cur" in
	--*)
		__gitcomp_builtin describe
		return
	esac
	__git_complete_refs
}

__git_diff_algorithms="myers minimal patience histogram"

__git_diff_submodule_formats="diff log short"

__git_color_moved_opts="no default plain blocks zebra dimmed-zebra"

__git_color_moved_ws_opts="no ignore-space-at-eol ignore-space-change
			ignore-all-space allow-indentation-change"

__git_ws_error_highlight_opts="context old new all default"

# Options for the diff machinery (diff, log, show, stash, range-diff, ...)
__git_diff_common_options="--stat --numstat --shortstat --summary
			--patch-with-stat --name-only --name-status --color
			--no-color --color-words --no-renames --check
			--color-moved --color-moved= --no-color-moved
			--color-moved-ws= --no-color-moved-ws
			--full-index --binary --abbrev --diff-filter=
			--find-copies --find-object --find-renames
			--no-relative --relative
			--find-copies-harder --ignore-cr-at-eol
			--text --ignore-space-at-eol --ignore-space-change
			--ignore-all-space --ignore-blank-lines --exit-code
			--quiet --ext-diff --no-ext-diff --unified=
			--no-prefix --src-prefix= --dst-prefix=
			--inter-hunk-context= --function-context
			--patience --histogram --minimal
			--raw --word-diff --word-diff-regex=
			--dirstat --dirstat= --dirstat-by-file
			--dirstat-by-file= --cumulative
			--diff-algorithm= --default-prefix
			--submodule --submodule= --ignore-submodules
			--indent-heuristic --no-indent-heuristic
			--textconv --no-textconv --break-rewrites
			--patch --no-patch --cc --combined-all-paths
			--anchored= --compact-summary --ignore-matching-lines=
			--irreversible-delete --line-prefix --no-stat
			--output= --output-indicator-context=
			--output-indicator-new= --output-indicator-old=
			--ws-error-highlight=
			--pickaxe-all --pickaxe-regex --patch-with-raw
"

# Options for diff/difftool
__git_diff_difftool_options="--cached --staged
			--base --ours --theirs --no-index --merge-base
			--ita-invisible-in-index --ita-visible-in-index
			$__git_diff_common_options"

_git_diff ()
{
	__git_has_doubledash && return

	case "$cur" in
	--diff-algorithm=*)
		__gitcomp "$__git_diff_algorithms" "" "${cur##--diff-algorithm=}"
		return
		;;
	--submodule=*)
		__gitcomp "$__git_diff_submodule_formats" "" "${cur##--submodule=}"
		return
		;;
	--color-moved=*)
		__gitcomp "$__git_color_moved_opts" "" "${cur##--color-moved=}"
		return
		;;
	--color-moved-ws=*)
		__gitcomp "$__git_color_moved_ws_opts" "" "${cur##--color-moved-ws=}"
		return
		;;
	--ws-error-highlight=*)
		__gitcomp "$__git_ws_error_highlight_opts" "" "${cur##--ws-error-highlight=}"
		return
		;;
	--*)
		__gitcomp "$__git_diff_difftool_options"
		return
		;;
	esac
	__git_complete_revlist_file
}

__git_mergetools_common="diffuse diffmerge ecmerge emerge kdiff3 meld opendiff
			tkdiff vimdiff nvimdiff gvimdiff xxdiff araxis p4merge
			bc codecompare smerge
"

_git_difftool ()
{
	__git_has_doubledash && return

	case "$cur" in
	--tool=*)
		__gitcomp "$__git_mergetools_common kompare" "" "${cur##--tool=}"
		return
		;;
	--*)
		__gitcomp_builtin difftool "$__git_diff_difftool_options"
		return
		;;
	esac
	__git_complete_revlist_file
}

__git_fetch_recurse_submodules="yes on-demand no"

_git_fetch ()
{
	case "$cur" in
	--recurse-submodules=*)
		__gitcomp "$__git_fetch_recurse_submodules" "" "${cur##--recurse-submodules=}"
		return
		;;
	--filter=*)
		__gitcomp "blob:none blob:limit= sparse:oid=" "" "${cur##--filter=}"
		return
		;;
	--*)
		__gitcomp_builtin fetch
		return
		;;
	esac
	__git_complete_remote_or_refspec
}

__git_format_patch_extra_options="
	--full-index --not --all --no-prefix --src-prefix=
	--dst-prefix= --notes
"

_git_format_patch ()
{
	case "$cur" in
	--thread=*)
		__gitcomp "
			deep shallow
			" "" "${cur##--thread=}"
		return
		;;
	--base=*|--interdiff=*|--range-diff=*)
		__git_complete_refs --cur="${cur#--*=}"
		return
		;;
	--*)
		__gitcomp_builtin format-patch "$__git_format_patch_extra_options"
		return
		;;
	esac
	__git_complete_revlist
}

_git_fsck ()
{
	case "$cur" in
	--*)
		__gitcomp_builtin fsck
		return
		;;
	esac
}

_git_gitk ()
{
	__gitk_main
}

# Lists matching symbol names from a tag (as in ctags) file.
# 1: List symbol names matching this word.
# 2: The tag file to list symbol names from.
# 3: A prefix to be added to each listed symbol name (optional).
# 4: A suffix to be appended to each listed symbol name (optional).
__git_match_ctag () {
	awk -v pfx="${3-}" -v sfx="${4-}" "
		/^${1//\//\\/}/ { print pfx \$1 sfx }
		" "$2"
}

# Complete symbol names from a tag file.
# Usage: __git_complete_symbol [<option>]...
# --tags=<file>: The tag file to list symbol names from instead of the
#                default "tags".
# --pfx=<prefix>: A prefix to be added to each symbol name.
# --cur=<word>: The current symbol name to be completed.  Defaults to
#               the current word to be completed.
# --sfx=<suffix>: A suffix to be appended to each symbol name instead
#                 of the default space.
__git_complete_symbol () {
	local tags=tags pfx="" cur_="${cur-}" sfx=" "

	while test $# != 0; do
		case "$1" in
		--tags=*)	tags="${1##--tags=}" ;;
		--pfx=*)	pfx="${1##--pfx=}" ;;
		--cur=*)	cur_="${1##--cur=}" ;;
		--sfx=*)	sfx="${1##--sfx=}" ;;
		*)		return 1 ;;
		esac
		shift
	done

	if test -r "$tags"; then
		__gitcomp_direct "$(__git_match_ctag "$cur_" "$tags" "$pfx" "$sfx")"
	fi
}

_git_grep ()
{
	__git_has_doubledash && return

	case "$cur" in
	--*)
		__gitcomp_builtin grep
		return
		;;
	esac

	case "$cword,$prev" in
	$((__git_cmd_idx+1)),*|*,-*)
		__git_complete_symbol && return
		;;
	esac

	__git_complete_refs
}

_git_help ()
{
	case "$cur" in
	--*)
		__gitcomp_builtin help
		return
		;;
	esac
	if test -n "${GIT_TESTING_ALL_COMMAND_LIST-}"
	then
		__gitcomp "$GIT_TESTING_ALL_COMMAND_LIST $(__git --list-cmds=alias,list-guide) gitk"
	else
		__gitcomp "$(__git --list-cmds=main,nohelpers,alias,list-guide) gitk"
	fi
}

_git_init ()
{
	case "$cur" in
	--shared=*)
		__gitcomp "
			false true umask group all world everybody
			" "" "${cur##--shared=}"
		return
		;;
	--*)
		__gitcomp_builtin init
		return
		;;
	esac
}

_git_ls_files ()
{
	case "$cur" in
	--*)
		__gitcomp_builtin ls-files
		return
		;;
	esac

	# XXX ignore options like --modified and always suggest all cached
	# files.
	__git_complete_index_file "--cached"
}

_git_ls_remote ()
{
	case "$cur" in
	--*)
		__gitcomp_builtin ls-remote
		return
		;;
	esac
	__gitcomp_nl "$(__git_remotes)"
}

_git_ls_tree ()
{
	case "$cur" in
	--*)
		__gitcomp_builtin ls-tree
		return
		;;
	esac

	__git_complete_file
}

# Options that go well for log, shortlog and gitk
__git_log_common_options="
	--not --all
	--branches --tags --remotes
	--first-parent --merges --no-merges
	--max-count=
	--max-age= --since= --after=
	--min-age= --until= --before=
	--min-parents= --max-parents=
	--no-min-parents --no-max-parents
	--alternate-refs --ancestry-path
	--author-date-order --basic-regexp
	--bisect --boundary --exclude-first-parent-only
	--exclude-hidden --extended-regexp
	--fixed-strings --grep-reflog
	--ignore-missing --left-only --perl-regexp
	--reflog --regexp-ignore-case --remove-empty
	--right-only --show-linear-break
	--show-notes-by-default --show-pulls
	--since-as-filter --single-worktree
"
# Options that go well for log and gitk (not shortlog)
__git_log_gitk_options="
	--dense --sparse --full-history
	--simplify-merges --simplify-by-decoration
	--left-right --notes --no-notes
"
# Options that go well for log and shortlog (not gitk)
__git_log_shortlog_options="
	--author= --committer= --grep=
	--all-match --invert-grep
"
# Options accepted by log and show
__git_log_show_options="
	--diff-merges --diff-merges= --no-diff-merges --dd --remerge-diff
	--encoding=
"

__git_diff_merges_opts="off none on first-parent 1 separate m combined c dense-combined cc remerge r"

__git_log_pretty_formats="oneline short medium full fuller reference email raw format: tformat: mboxrd"
__git_log_date_formats="relative iso8601 iso8601-strict rfc2822 short local default human raw unix auto: format:"

# Complete porcelain (i.e. not git-rev-list) options and at least some
# option arguments accepted by git-log.  Note that this same set of options
# are also accepted by some other git commands besides git-log.
__git_complete_log_opts ()
{
	COMPREPLY=()

	local merge=""
	if __git_pseudoref_exists MERGE_HEAD; then
		merge="--merge"
	fi
	case "$prev,$cur" in
	-L,:*:*)
		return	# fall back to Bash filename completion
		;;
	-L,:*)
		__git_complete_symbol --cur="${cur#:}" --sfx=":"
		return
		;;
	-G,*|-S,*)
		__git_complete_symbol
		return
		;;
	esac
	case "$cur" in
	--pretty=*|--format=*)
		__gitcomp "$__git_log_pretty_formats $(__git_pretty_aliases)
			" "" "${cur#*=}"
		return
		;;
	--date=*)
		__gitcomp "$__git_log_date_formats" "" "${cur##--date=}"
		return
		;;
	--decorate=*)
		__gitcomp "full short no" "" "${cur##--decorate=}"
		return
		;;
	--diff-algorithm=*)
		__gitcomp "$__git_diff_algorithms" "" "${cur##--diff-algorithm=}"
		return
		;;
	--submodule=*)
		__gitcomp "$__git_diff_submodule_formats" "" "${cur##--submodule=}"
		return
		;;
	--ws-error-highlight=*)
		__gitcomp "$__git_ws_error_highlight_opts" "" "${cur##--ws-error-highlight=}"
		return
		;;
	--no-walk=*)
		__gitcomp "sorted unsorted" "" "${cur##--no-walk=}"
		return
		;;
	--diff-merges=*)
                __gitcomp "$__git_diff_merges_opts" "" "${cur##--diff-merges=}"
                return
                ;;
	--*)
		__gitcomp "
			$__git_log_common_options
			$__git_log_shortlog_options
			$__git_log_gitk_options
			$__git_log_show_options
			--root --topo-order --date-order --reverse
			--follow --full-diff
			--abbrev-commit --no-abbrev-commit --abbrev=
			--relative-date --date=
			--pretty= --format= --oneline
			--show-signature
			--cherry-mark
			--cherry-pick
			--graph
			--decorate --decorate= --no-decorate
			--walk-reflogs
			--no-walk --no-walk= --do-walk
			--parents --children
			--expand-tabs --expand-tabs= --no-expand-tabs
			--clear-decorations --decorate-refs=
			--decorate-refs-exclude=
			$merge
			$__git_diff_common_options
			"
		return
		;;
	-L:*:*)
		return	# fall back to Bash filename completion
		;;
	-L:*)
		__git_complete_symbol --cur="${cur#-L:}" --sfx=":"
		return
		;;
	-G*)
		__git_complete_symbol --pfx="-G" --cur="${cur#-G}"
		return
		;;
	-S*)
		__git_complete_symbol --pfx="-S" --cur="${cur#-S}"
		return
		;;
	esac
}

_git_log ()
{
	__git_has_doubledash && return
	__git_find_repo_path

	__git_complete_log_opts
        [ ${#COMPREPLY[@]} -eq 0 ] || return

	__git_complete_revlist
}

_git_merge ()
{
	__git_complete_strategy && return

	case "$cur" in
	--*)
		__gitcomp_builtin merge
		return
	esac
	__git_complete_refs
}

_git_mergetool ()
{
	case "$cur" in
	--tool=*)
		__gitcomp "$__git_mergetools_common tortoisemerge" "" "${cur##--tool=}"
		return
		;;
	--*)
		__gitcomp "--tool= --prompt --no-prompt --gui --no-gui"
		return
		;;
	esac
}

_git_merge_base ()
{
	case "$cur" in
	--*)
		__gitcomp_builtin merge-base
		return
		;;
	esac
	__git_complete_refs
}

_git_mv ()
{
	case "$cur" in
	--*)
		__gitcomp_builtin mv
		return
		;;
	esac

	if [ $(__git_count_arguments "mv") -gt 0 ]; then
		# We need to show both cached and untracked files (including
		# empty directories) since this may not be the last argument.
		__git_complete_index_file "--cached --others --directory"
	else
		__git_complete_index_file "--cached"
	fi
}

_git_notes ()
{
	local subcommands='add append copy edit get-ref list merge prune remove show'
	local subcommand="$(__git_find_on_cmdline "$subcommands")"

	case "$subcommand,$cur" in
	,--*)
		__gitcomp_builtin notes
		;;
	,*)
		case "$prev" in
		--ref)
			__git_complete_refs
			;;
		*)
			__gitcomp "$subcommands --ref"
			;;
		esac
		;;
	*,--reuse-message=*|*,--reedit-message=*)
		__git_complete_refs --cur="${cur#*=}"
		;;
	*,--*)
		__gitcomp_builtin notes_$subcommand
		;;
	prune,*|get-ref,*)
		# this command does not take a ref, do not complete it
		;;
	*)
		case "$prev" in
		-m|-F)
			;;
		*)
			__git_complete_refs
			;;
		esac
		;;
	esac
}

_git_pull ()
{
	__git_complete_strategy && return

	case "$cur" in
	--recurse-submodules=*)
		__gitcomp "$__git_fetch_recurse_submodules" "" "${cur##--recurse-submodules=}"
		return
		;;
	--*)
		__gitcomp_builtin pull

		return
		;;
	esac
	__git_complete_remote_or_refspec
}

__git_push_recurse_submodules="check on-demand only"

__git_complete_force_with_lease ()
{
	local cur_=$1

	case "$cur_" in
	--*=)
		;;
	*:*)
		__git_complete_refs --cur="${cur_#*:}"
		;;
	*)
		__git_complete_refs --cur="$cur_"
		;;
	esac
}

_git_push ()
{
	case "$prev" in
	--repo)
		__gitcomp_nl "$(__git_remotes)"
		return
		;;
	--recurse-submodules)
		__gitcomp "$__git_push_recurse_submodules"
		return
		;;
	esac
	case "$cur" in
	--repo=*)
		__gitcomp_nl "$(__git_remotes)" "" "${cur##--repo=}"
		return
		;;
	--recurse-submodules=*)
		__gitcomp "$__git_push_recurse_submodules" "" "${cur##--recurse-submodules=}"
		return
		;;
	--force-with-lease=*)
		__git_complete_force_with_lease "${cur##--force-with-lease=}"
		return
		;;
	--*)
		__gitcomp_builtin push
		return
		;;
	esac
	__git_complete_remote_or_refspec
}

_git_range_diff ()
{
	case "$cur" in
	--*)
		__gitcomp "
			--creation-factor= --no-dual-color
			$__git_diff_common_options
		"
		return
		;;
	esac
	__git_complete_revlist
}

__git_rebase_inprogress_options="--continue --skip --abort --quit --show-current-patch"
__git_rebase_interactive_inprogress_options="$__git_rebase_inprogress_options --edit-todo"

_git_rebase ()
{
	__git_find_repo_path
	if [ -f "$__git_repo_path"/rebase-merge/interactive ]; then
		__gitcomp "$__git_rebase_interactive_inprogress_options"
		return
	elif [ -d "$__git_repo_path"/rebase-apply ] || \
	     [ -d "$__git_repo_path"/rebase-merge ]; then
		__gitcomp "$__git_rebase_inprogress_options"
		return
	fi
	__git_complete_strategy && return
	case "$cur" in
	--whitespace=*)
		__gitcomp "$__git_whitespacelist" "" "${cur##--whitespace=}"
		return
		;;
	--onto=*)
		__git_complete_refs --cur="${cur##--onto=}"
		return
		;;
	--*)
		__gitcomp_builtin rebase "" \
			"$__git_rebase_interactive_inprogress_options"

		return
	esac
	__git_complete_refs
}

_git_reflog ()
{
	local subcommands subcommand

	__git_resolve_builtins "reflog"

	subcommands="$___git_resolved_builtins"
	subcommand="$(__git_find_subcommand "$subcommands" "show")"

	case "$subcommand,$cur" in
	show,--*)
		__gitcomp "
			$__git_log_common_options
			"
		return
		;;
	$subcommand,--*)
		__gitcomp_builtin "reflog_$subcommand"
		return
		;;
	esac

	__git_complete_refs

	if [ $((cword - __git_cmd_idx)) -eq 1 ]; then
		__gitcompappend "$subcommands" "" "$cur" " "
	fi
}

__git_send_email_confirm_options="always never auto cc compose"
__git_send_email_suppresscc_options="author self cc bodycc sob cccmd body all"

_git_send_email ()
{
	case "$prev" in
	--to|--cc|--bcc|--from)
		__gitcomp "$(__git send-email --dump-aliases)"
		return
		;;
	esac

	case "$cur" in
	--confirm=*)
		__gitcomp "
			$__git_send_email_confirm_options
			" "" "${cur##--confirm=}"
		return
		;;
	--suppress-cc=*)
		__gitcomp "
			$__git_send_email_suppresscc_options
			" "" "${cur##--suppress-cc=}"

		return
		;;
	--smtp-encryption=*)
		__gitcomp "ssl tls" "" "${cur##--smtp-encryption=}"
		return
		;;
	--thread=*)
		__gitcomp "
			deep shallow
			" "" "${cur##--thread=}"
		return
		;;
	--to=*|--cc=*|--bcc=*|--from=*)
		__gitcomp "$(__git send-email --dump-aliases)" "" "${cur#--*=}"
		return
		;;
	--*)
		__gitcomp_builtin send-email "$__git_format_patch_extra_options"
		return
		;;
	esac
	__git_complete_revlist
}

_git_stage ()
{
	_git_add
}

_git_status ()
{
	local complete_opt
	local untracked_state

	case "$cur" in
	--ignore-submodules=*)
		__gitcomp "none untracked dirty all" "" "${cur##--ignore-submodules=}"
		return
		;;
	--untracked-files=*)
		__gitcomp "$__git_untracked_file_modes" "" "${cur##--untracked-files=}"
		return
		;;
	--column=*)
		__gitcomp "
			always never auto column row plain dense nodense
			" "" "${cur##--column=}"
		return
		;;
	--*)
		__gitcomp_builtin status
		return
		;;
	esac

	untracked_state="$(__git_get_option_value "-u" "--untracked-files=" \
		"$__git_untracked_file_modes" "status.showUntrackedFiles")"

	case "$untracked_state" in
	no)
		# --ignored option does not matter
		complete_opt=
		;;
	all|normal|*)
		complete_opt="--cached --directory --no-empty-directory --others"

		if [ -n "$(__git_find_on_cmdline "--ignored")" ]; then
			complete_opt="$complete_opt --ignored --exclude=*"
		fi
		;;
	esac

	__git_complete_index_file "$complete_opt"
}

_git_switch ()
{
	local dwim_opt="$(__git_checkout_default_dwim_mode)"

	case "$prev" in
	-c|-C|--orphan)
		# Complete local branches (and DWIM branch
		# remote branch names) for an option argument
		# specifying a new branch name. This is for
		# convenience, assuming new branches are
		# possibly based on pre-existing branch names.
		__git_complete_refs $dwim_opt --mode="heads"
		return
		;;
	*)
		;;
	esac

	case "$cur" in
	--conflict=*)
		__gitcomp "diff3 merge zdiff3" "" "${cur##--conflict=}"
		;;
	--*)
		__gitcomp_builtin switch
		;;
	*)
		# Unlike in git checkout, git switch --orphan does not take
		# a start point. Thus we really have nothing to complete after
		# the branch name.
		if [ -n "$(__git_find_on_cmdline "--orphan")" ]; then
			return
		fi

		# At this point, we've already handled special completion for
		# -c/-C, and --orphan. There are 3 main things left to
		# complete:
		# 1) a start-point for -c/-C or -d/--detach
		# 2) a remote head, for --track
		# 3) a branch name, possibly including DWIM remote branches

		if [ -n "$(__git_find_on_cmdline "-c -C -d --detach")" ]; then
			__git_complete_refs --mode="refs"
		elif [ -n "$(__git_find_on_cmdline "-t --track")" ]; then
			__git_complete_refs --mode="remote-heads"
		else
			__git_complete_refs $dwim_opt --mode="heads"
		fi
		;;
	esac
}

__git_config_get_set_variables ()
{
	local prevword word config_file= c=$cword
	while [ $c -gt "$__git_cmd_idx" ]; do
		word="${words[c]}"
		case "$word" in
		--system|--global|--local|--file=*)
			config_file="$word"
			break
			;;
		-f|--file)
			config_file="$word $prevword"
			break
			;;
		esac
		prevword=$word
		c=$((--c))
	done

	__git config $config_file --name-only --list
}

__git_config_vars=
__git_compute_config_vars ()
{
	test -n "$__git_config_vars" ||
	__git_config_vars="$(git help --config-for-completion)"
}

__git_config_vars_all=
__git_compute_config_vars_all ()
{
	test -n "$__git_config_vars_all" ||
	__git_config_vars_all="$(git --no-pager help --config)"
}

__git_compute_first_level_config_vars_for_section ()
{
	local section="$1"
	__git_compute_config_vars
	local this_section="__git_first_level_config_vars_for_section_${section}"
	test -n "${!this_section}" ||
	printf -v "__git_first_level_config_vars_for_section_${section}" %s \
		"$(echo "$__git_config_vars" | awk -F. "/^${section}\.[a-z]/ { print \$2 }")"
}

__git_compute_second_level_config_vars_for_section ()
{
	local section="$1"
	__git_compute_config_vars_all
	local this_section="__git_second_level_config_vars_for_section_${section}"
	test -n "${!this_section}" ||
	printf -v "__git_second_level_config_vars_for_section_${section}" %s \
		"$(echo "$__git_config_vars_all" | awk -F. "/^${section}\.</ { print \$3 }")"
}

__git_config_sections=
__git_compute_config_sections ()
{
	test -n "$__git_config_sections" ||
	__git_config_sections="$(git help --config-sections-for-completion)"
}

# Completes possible values of various configuration variables.
#
# Usage: __git_complete_config_variable_value [<option>]...
# --varname=<word>: The name of the configuration variable whose value is
#                   to be completed.  Defaults to the previous word on the
#                   command line.
# --cur=<word>: The current value to be completed.  Defaults to the current
#               word to be completed.
__git_complete_config_variable_value ()
{
	local varname="$prev" cur_="$cur"

	while test $# != 0; do
		case "$1" in
		--varname=*)	varname="${1##--varname=}" ;;
		--cur=*)	cur_="${1##--cur=}" ;;
		*)		return 1 ;;
		esac
		shift
	done

	if [ "${BASH_VERSINFO[0]:-0}" -ge 4 ]; then
		varname="${varname,,}"
	else
		varname="$(echo "$varname" |tr A-Z a-z)"
	fi

	case "$varname" in
	branch.*.remote|branch.*.pushremote)
		__gitcomp_nl "$(__git_remotes)" "" "$cur_"
		return
		;;
	branch.*.merge)
		__git_complete_refs --cur="$cur_"
		return
		;;
	branch.*.rebase)
		__gitcomp "false true merges interactive" "" "$cur_"
		return
		;;
	remote.pushdefault)
		__gitcomp_nl "$(__git_remotes)" "" "$cur_"
		return
		;;
	remote.*.fetch)
		local remote="${varname#remote.}"
		remote="${remote%.fetch}"
		if [ -z "$cur_" ]; then
			__gitcomp_nl "refs/heads/" "" "" ""
			return
		fi
		__gitcomp_nl "$(__git_refs_remotes "$remote")" "" "$cur_"
		return
		;;
	remote.*.push)
		local remote="${varname#remote.}"
		remote="${remote%.push}"
		__gitcomp_nl "$(__git for-each-ref \
			--format='%(refname):%(refname)' refs/heads)" "" "$cur_"
		return
		;;
	pull.twohead|pull.octopus)
		__git_compute_merge_strategies
		__gitcomp "$__git_merge_strategies" "" "$cur_"
		return
		;;
	color.pager)
		__gitcomp "false true" "" "$cur_"
		return
		;;
	color.*.*)
		__gitcomp "
			normal black red green yellow blue magenta cyan white
			bold dim ul blink reverse
			" "" "$cur_"
		return
		;;
	color.*)
		__gitcomp "false true always never auto" "" "$cur_"
		return
		;;
	diff.submodule)
		__gitcomp "$__git_diff_submodule_formats" "" "$cur_"
		return
		;;
	help.format)
		__gitcomp "man info web html" "" "$cur_"
		return
		;;
	log.date)
		__gitcomp "$__git_log_date_formats" "" "$cur_"
		return
		;;
	sendemail.aliasfiletype)
		__gitcomp "mutt mailrc pine elm gnus" "" "$cur_"
		return
		;;
	sendemail.confirm)
		__gitcomp "$__git_send_email_confirm_options" "" "$cur_"
		return
		;;
	sendemail.suppresscc)
		__gitcomp "$__git_send_email_suppresscc_options" "" "$cur_"
		return
		;;
	sendemail.transferencoding)
		__gitcomp "7bit 8bit quoted-printable base64" "" "$cur_"
		return
		;;
	*.*)
		return
		;;
	esac
}

# Completes configuration sections, subsections, variable names.
#
# Usage: __git_complete_config_variable_name [<option>]...
# --cur=<word>: The current configuration section/variable name to be
#               completed.  Defaults to the current word to be completed.
# --sfx=<suffix>: A suffix to be appended to each fully completed
#                 configuration variable name (but not to sections or
#                 subsections) instead of the default space.
__git_complete_config_variable_name ()
{
	local cur_="$cur" sfx

	while test $# != 0; do
		case "$1" in
		--cur=*)	cur_="${1##--cur=}" ;;
		--sfx=*)	sfx="${1##--sfx=}" ;;
		*)		return 1 ;;
		esac
		shift
	done

	case "$cur_" in
	branch.*.*|guitool.*.*|difftool.*.*|man.*.*|mergetool.*.*|remote.*.*|submodule.*.*|url.*.*)
		local pfx="${cur_%.*}."
		cur_="${cur_##*.}"
		local section="${pfx%.*.}"
		__git_compute_second_level_config_vars_for_section "${section}"
		local this_section="__git_second_level_config_vars_for_section_${section}"
		__gitcomp "${!this_section}" "$pfx" "$cur_" "$sfx"
		return
		;;
	branch.*)
		local pfx="${cur_%.*}."
		cur_="${cur_#*.}"
		local section="${pfx%.}"
		__gitcomp_direct "$(__git_heads "$pfx" "$cur_" ".")"
		__git_compute_first_level_config_vars_for_section "${section}"
		local this_section="__git_first_level_config_vars_for_section_${section}"
		__gitcomp_nl_append "${!this_section}" "$pfx" "$cur_" "${sfx:- }"
		return
		;;
	pager.*)
		local pfx="${cur_%.*}."
		cur_="${cur_#*.}"
		__git_compute_all_commands
		__gitcomp_nl "$__git_all_commands" "$pfx" "$cur_" "${sfx:- }"
		return
		;;
	remote.*)
		local pfx="${cur_%.*}."
		cur_="${cur_#*.}"
		local section="${pfx%.}"
		__gitcomp_nl "$(__git_remotes)" "$pfx" "$cur_" "."
		__git_compute_first_level_config_vars_for_section "${section}"
		local this_section="__git_first_level_config_vars_for_section_${section}"
		__gitcomp_nl_append "${!this_section}" "$pfx" "$cur_" "${sfx:- }"
		return
		;;
	submodule.*)
		local pfx="${cur_%.*}."
		cur_="${cur_#*.}"
		local section="${pfx%.}"
		__gitcomp_nl "$(__git config -f "$(__git rev-parse --show-toplevel)/.gitmodules" --get-regexp 'submodule.*.path' | awk -F. '{print $2}')" "$pfx" "$cur_" "."
		__git_compute_first_level_config_vars_for_section "${section}"
		local this_section="__git_first_level_config_vars_for_section_${section}"
		__gitcomp_nl_append "${!this_section}" "$pfx" "$cur_" "${sfx:- }"
		return
		;;
	*.*)
		__git_compute_config_vars
		__gitcomp "$__git_config_vars" "" "$cur_" "$sfx"
		;;
	*)
		__git_compute_config_sections
		__gitcomp "$__git_config_sections" "" "$cur_" "."
		;;
	esac
}

# Completes '='-separated configuration sections/variable names and values
# for 'git -c section.name=value'.
#
# Usage: __git_complete_config_variable_name_and_value [<option>]...
# --cur=<word>: The current configuration section/variable name/value to be
#               completed. Defaults to the current word to be completed.
__git_complete_config_variable_name_and_value ()
{
	local cur_="$cur"

	while test $# != 0; do
		case "$1" in
		--cur=*)	cur_="${1##--cur=}" ;;
		*)		return 1 ;;
		esac
		shift
	done

	case "$cur_" in
	*=*)
		__git_complete_config_variable_value \
			--varname="${cur_%%=*}" --cur="${cur_#*=}"
		;;
	*)
		__git_complete_config_variable_name --cur="$cur_" --sfx='='
		;;
	esac
}

_git_config ()
{
	local subcommands subcommand

	__git_resolve_builtins "config"

	subcommands="$___git_resolved_builtins"
	subcommand="$(__git_find_subcommand "$subcommands")"

	if [ -z "$subcommand" ]
	then
		__gitcomp "$subcommands"
		return
	fi

	case "$cur" in
	--*)
		__gitcomp_builtin "config_$subcommand"
		return
		;;
	esac

	case "$subcommand" in
	get)
		__gitcomp_nl "$(__git_config_get_set_variables)"
		;;
	set)
		case "$prev" in
		*.*)
			__git_complete_config_variable_value
			;;
		*)
			__git_complete_config_variable_name
			;;
		esac
		;;
	unset)
		__gitcomp_nl "$(__git_config_get_set_variables)"
		;;
	esac
}

_git_remote ()
{
	local subcommands="
		add rename remove set-head set-branches
		get-url set-url show prune update
		"
	local subcommand="$(__git_find_on_cmdline "$subcommands")"
	if [ -z "$subcommand" ]; then
		case "$cur" in
		--*)
			__gitcomp_builtin remote
			;;
		*)
			__gitcomp "$subcommands"
			;;
		esac
		return
	fi

	case "$subcommand,$cur" in
	add,--*)
		__gitcomp_builtin remote_add
		;;
	add,*)
		;;
	set-head,--*)
		__gitcomp_builtin remote_set-head
		;;
	set-branches,--*)
		__gitcomp_builtin remote_set-branches
		;;
	set-head,*|set-branches,*)
		__git_complete_remote_or_refspec
		;;
	update,--*)
		__gitcomp_builtin remote_update
		;;
	update,*)
		__gitcomp "$(__git_remotes) $(__git_get_config_variables "remotes")"
		;;
	set-url,--*)
		__gitcomp_builtin remote_set-url
		;;
	get-url,--*)
		__gitcomp_builtin remote_get-url
		;;
	prune,--*)
		__gitcomp_builtin remote_prune
		;;
	*)
		__gitcomp_nl "$(__git_remotes)"
		;;
	esac
}

_git_replace ()
{
	case "$cur" in
	--format=*)
		__gitcomp "short medium long" "" "${cur##--format=}"
		return
		;;
	--*)
		__gitcomp_builtin replace
		return
		;;
	esac
	__git_complete_refs
}

_git_rerere ()
{
	local subcommands="clear forget diff remaining status gc"
	local subcommand="$(__git_find_on_cmdline "$subcommands")"
	if test -z "$subcommand"
	then
		__gitcomp "$subcommands"
		return
	fi
}

_git_reset ()
{
	__git_has_doubledash && return

	case "$cur" in
	--*)
		__gitcomp_builtin reset
		return
		;;
	esac
	__git_complete_refs
}

_git_restore ()
{
	case "$prev" in
	-s)
		__git_complete_refs
		return
		;;
	esac

	case "$cur" in
	--conflict=*)
		__gitcomp "diff3 merge zdiff3" "" "${cur##--conflict=}"
		;;
	--source=*)
		__git_complete_refs --cur="${cur##--source=}"
		;;
	--*)
		__gitcomp_builtin restore
		;;
	*)
		if __git_pseudoref_exists HEAD; then
			__git_complete_index_file "--modified"
		fi
	esac
}

__git_revert_inprogress_options=$__git_sequencer_inprogress_options

_git_revert ()
{
	if __git_pseudoref_exists REVERT_HEAD; then
		__gitcomp "$__git_revert_inprogress_options"
		return
	fi
	__git_complete_strategy && return
	case "$cur" in
	--*)
		__gitcomp_builtin revert "" \
			"$__git_revert_inprogress_options"
		return
		;;
	esac
	__git_complete_refs
}

_git_rm ()
{
	case "$cur" in
	--*)
		__gitcomp_builtin rm
		return
		;;
	esac

	__git_complete_index_file "--cached"
}

_git_shortlog ()
{
	__git_has_doubledash && return

	case "$cur" in
	--*)
		__gitcomp "
			$__git_log_common_options
			$__git_log_shortlog_options
			--numbered --summary --email
			"
		return
		;;
	esac
	__git_complete_revlist
}

_git_show ()
{
	__git_has_doubledash && return

	case "$cur" in
	--pretty=*|--format=*)
		__gitcomp "$__git_log_pretty_formats $(__git_pretty_aliases)
			" "" "${cur#*=}"
		return
		;;
	--diff-algorithm=*)
		__gitcomp "$__git_diff_algorithms" "" "${cur##--diff-algorithm=}"
		return
		;;
	--submodule=*)
		__gitcomp "$__git_diff_submodule_formats" "" "${cur##--submodule=}"
		return
		;;
	--color-moved=*)
		__gitcomp "$__git_color_moved_opts" "" "${cur##--color-moved=}"
		return
		;;
	--color-moved-ws=*)
		__gitcomp "$__git_color_moved_ws_opts" "" "${cur##--color-moved-ws=}"
		return
		;;
	--ws-error-highlight=*)
		__gitcomp "$__git_ws_error_highlight_opts" "" "${cur##--ws-error-highlight=}"
		return
		;;
	--diff-merges=*)
                __gitcomp "$__git_diff_merges_opts" "" "${cur##--diff-merges=}"
                return
                ;;
	--*)
		__gitcomp "--pretty= --format= --abbrev-commit --no-abbrev-commit
			--oneline --show-signature
			--expand-tabs --expand-tabs= --no-expand-tabs
			$__git_log_show_options
			$__git_diff_common_options
			"
		return
		;;
	esac
	__git_complete_revlist_file
}

_git_show_branch ()
{
	case "$cur" in
	--*)
		__gitcomp_builtin show-branch
		return
		;;
	esac
	__git_complete_revlist
}

__gitcomp_directories ()
{
	local _tmp_dir _tmp_completions _found=0

	# Get the directory of the current token; this differs from dirname
	# in that it keeps up to the final trailing slash.  If no slash found
	# that's fine too.
	[[ "$cur" =~ .*/ ]]
	_tmp_dir=$BASH_REMATCH

	# Find possible directory completions, adding trailing '/' characters,
	# de-quoting, and handling unusual characters.
	while IFS= read -r -d $'\0' c ; do
		# If there are directory completions, find ones that start
		# with "$cur", the current token, and put those in COMPREPLY
		if [[ $c == "$cur"* ]]; then
			COMPREPLY+=("$c/")
			_found=1
		fi
	done < <(__git ls-tree -z -d --name-only HEAD $_tmp_dir)

	if [[ $_found == 0 ]] && [[ "$cur" =~ /$ ]]; then
		# No possible further completions any deeper, so assume we're at
		# a leaf directory and just consider it complete
		__gitcomp_direct_append "$cur "
	elif [[ $_found == 0 ]]; then
		# No possible completions found.  Avoid falling back to
		# bash's default file and directory completion, because all
		# valid completions have already been searched and the
		# fallbacks can do nothing but mislead.  In fact, they can
		# mislead in three different ways:
		#    1) Fallback file completion makes no sense when asking
		#       for directory completions, as this function does.
		#    2) Fallback directory completion is bad because
		#       e.g. "/pro" is invalid and should NOT complete to
		#       "/proc".
		#    3) Fallback file/directory completion only completes
		#       on paths that exist in the current working tree,
		#       i.e. which are *already* part of their
		#       sparse-checkout.  Thus, normal file and directory
		#       completion is always useless for "git
		#       sparse-checkout add" and is also probelmatic for
		#       "git sparse-checkout set" unless using it to
		#       strictly narrow the checkout.
		COMPREPLY=( "" )
	fi
}

# In non-cone mode, the arguments to {set,add} are supposed to be
# patterns, relative to the toplevel directory.  These can be any kind
# of general pattern, like 'subdir/*.c' and we can't complete on all
# of those.  However, if the user presses Tab to get tab completion, we
# presume that they are trying to provide a pattern that names a specific
# path.
__gitcomp_slash_leading_paths ()
{
	local dequoted_word pfx="" cur_ toplevel

	# Since we are dealing with a sparse-checkout, subdirectories may not
	# exist in the local working copy.  Therefore, we want to run all
	# ls-files commands relative to the repository toplevel.
	toplevel="$(git rev-parse --show-toplevel)/"

	__git_dequote "$cur"

	# If the paths provided by the user already start with '/', then
	# they are considered relative to the toplevel of the repository
	# already.  If they do not start with /, then we need to adjust
	# them to start with the appropriate prefix.
	case "$cur" in
	/*)
		cur="${cur:1}"
		;;
	*)
		pfx="$(__git rev-parse --show-prefix)"
	esac

	# Since sparse-index is limited to cone-mode, in non-cone-mode the
	# list of valid paths is precisely the cached files in the index.
	#
	# NEEDSWORK:
	#   1) We probably need to take care of cases where ls-files
	#      responds with special quoting.
	#   2) We probably need to take care of cases where ${cur} has
	#      some kind of special quoting.
	#   3) On top of any quoting from 1 & 2, we have to provide an extra
	#      level of quoting for any paths that contain a '*', '?', '\',
	#      '[', ']', or leading '#' or '!' since those will be
	#      interpreted by sparse-checkout as something other than a
	#      literal path character.
	# Since there are two types of quoting here, this might get really
	# complex.  For now, just punt on all of this...
	completions="$(__git -C "${toplevel}" -c core.quotePath=false \
			 ls-files --cached -- "${pfx}${cur}*" \
			 | sed -e s%^%/% -e 's%$% %')"
	# Note, above, though that we needed all of the completions to be
	# prefixed with a '/', and we want to add a space so that bash
	# completion will actually complete an entry and let us move on to
	# the next one.

	# Return what we've found.
	if test -n "$completions"; then
		# We found some completions; return them
		local IFS=$'\n'
		COMPREPLY=($completions)
	else
		# Do NOT fall back to bash-style all-local-files-and-dirs
		# when we find no match.  Such options are worse than
		# useless:
		#     1. "git sparse-checkout add" needs paths that are NOT
		#        currently in the working copy.  "git
		#        sparse-checkout set" does as well, except in the
		#        special cases when users are only trying to narrow
		#        their sparse checkout to a subset of what they
		#        already have.
		#
		#     2. A path like '.config' is ambiguous as to whether
		#        the user wants all '.config' files throughout the
		#        tree, or just the one under the current directory.
		#        It would result in a warning from the
		#        sparse-checkout command due to this.  As such, all
		#        completions of paths should be prefixed with a
		#        '/'.
		#
		#     3. We don't want paths prefixed with a '/' to
		#        complete files in the system root directory, we
		#        want it to complete on files relative to the
		#        repository root.
		#
		# As such, make sure that NO completions are offered rather
		# than falling back to bash's default completions.
		COMPREPLY=( "" )
	fi
}

_git_sparse_checkout ()
{
	local subcommands="list init set disable add reapply"
	local subcommand="$(__git_find_on_cmdline "$subcommands")"
	local using_cone=true
	if [ -z "$subcommand" ]; then
		__gitcomp "$subcommands"
		return
	fi

	case "$subcommand,$cur" in
	*,--*)
		__gitcomp_builtin sparse-checkout_$subcommand "" "--"
		;;
	set,*|add,*)
		if [[ "$(__git config core.sparseCheckout)" == "true" &&
		      "$(__git config core.sparseCheckoutCone)" == "false" &&
		      -z "$(__git_find_on_cmdline --cone)" ]]; then
			using_cone=false
		fi
		if [[ -n "$(__git_find_on_cmdline --no-cone)" ]]; then
			using_cone=false
		fi
		if [[ "$using_cone" == "true" ]]; then
			__gitcomp_directories
		else
			 __gitcomp_slash_leading_paths
		fi
	esac
}

_git_stash ()
{
	local subcommands='push list show apply clear drop pop create branch'
	local subcommand="$(__git_find_on_cmdline "$subcommands save")"

	if [ -z "$subcommand" ]; then
		case "$((cword - __git_cmd_idx)),$cur" in
		*,--*)
			__gitcomp_builtin stash_push
			;;
		1,sa*)
			__gitcomp "save"
			;;
		1,*)
			__gitcomp "$subcommands"
			;;
		esac
		return
	fi

	case "$subcommand,$cur" in
	list,--*)
		# NEEDSWORK: can we somehow unify this with the options in _git_log() and _git_show()
		__gitcomp_builtin stash_list "$__git_log_common_options $__git_diff_common_options"
		;;
	show,--*)
		__gitcomp_builtin stash_show "$__git_diff_common_options"
		;;
	*,--*)
		__gitcomp_builtin "stash_$subcommand"
		;;
	branch,*)
		if [ $cword -eq $((__git_cmd_idx+2)) ]; then
			__git_complete_refs
		else
			__gitcomp_nl "$(__git stash list \
					| sed -n -e 's/:.*//p')"
		fi
		;;
	show,*|apply,*|drop,*|pop,*)
		__gitcomp_nl "$(__git stash list \
				| sed -n -e 's/:.*//p')"
		;;
	esac
}

_git_submodule ()
{
	__git_has_doubledash && return

	local subcommands="add status init deinit update set-branch set-url summary foreach sync absorbgitdirs"
	local subcommand="$(__git_find_on_cmdline "$subcommands")"
	if [ -z "$subcommand" ]; then
		case "$cur" in
		--*)
			__gitcomp "--quiet"
			;;
		*)
			__gitcomp "$subcommands"
			;;
		esac
		return
	fi

	case "$subcommand,$cur" in
	add,--*)
		__gitcomp "--branch --force --name --reference --depth"
		;;
	status,--*)
		__gitcomp "--cached --recursive"
		;;
	deinit,--*)
		__gitcomp "--force --all"
		;;
	update,--*)
		__gitcomp "
			--init --remote --no-fetch
			--recommend-shallow --no-recommend-shallow
			--force --rebase --merge --reference --depth --recursive --jobs
		"
		;;
	set-branch,--*)
		__gitcomp "--default --branch"
		;;
	summary,--*)
		__gitcomp "--cached --files --summary-limit"
		;;
	foreach,--*|sync,--*)
		__gitcomp "--recursive"
		;;
	*)
		;;
	esac
}

_git_svn ()
{
	local subcommands="
		init fetch clone rebase dcommit log find-rev
		set-tree commit-diff info create-ignore propget
		proplist show-ignore show-externals branch tag blame
		migrate mkdirs reset gc
		"
	local subcommand="$(__git_find_on_cmdline "$subcommands")"
	if [ -z "$subcommand" ]; then
		__gitcomp "$subcommands"
	else
		local remote_opts="--username= --config-dir= --no-auth-cache"
		local fc_opts="
			--follow-parent --authors-file= --repack=
			--no-metadata --use-svm-props --use-svnsync-props
			--log-window-size= --no-checkout --quiet
			--repack-flags --use-log-author --localtime
			--add-author-from
			--recursive
			--ignore-paths= --include-paths= $remote_opts
			"
		local init_opts="
			--template= --shared= --trunk= --tags=
			--branches= --stdlayout --minimize-url
			--no-metadata --use-svm-props --use-svnsync-props
			--rewrite-root= --prefix= $remote_opts
			"
		local cmt_opts="
			--edit --rmdir --find-copies-harder --copy-similarity=
			"

		case "$subcommand,$cur" in
		fetch,--*)
			__gitcomp "--revision= --fetch-all $fc_opts"
			;;
		clone,--*)
			__gitcomp "--revision= $fc_opts $init_opts"
			;;
		init,--*)
			__gitcomp "$init_opts"
			;;
		dcommit,--*)
			__gitcomp "
				--merge --strategy= --verbose --dry-run
				--fetch-all --no-rebase --commit-url
				--revision --interactive $cmt_opts $fc_opts
				"
			;;
		set-tree,--*)
			__gitcomp "--stdin $cmt_opts $fc_opts"
			;;
		create-ignore,--*|propget,--*|proplist,--*|show-ignore,--*|\
		show-externals,--*|mkdirs,--*)
			__gitcomp "--revision="
			;;
		log,--*)
			__gitcomp "
				--limit= --revision= --verbose --incremental
				--oneline --show-commit --non-recursive
				--authors-file= --color
				"
			;;
		rebase,--*)
			__gitcomp "
				--merge --verbose --strategy= --local
				--fetch-all --dry-run $fc_opts
				"
			;;
		commit-diff,--*)
			__gitcomp "--message= --file= --revision= $cmt_opts"
			;;
		info,--*)
			__gitcomp "--url"
			;;
		branch,--*)
			__gitcomp "--dry-run --message --tag"
			;;
		tag,--*)
			__gitcomp "--dry-run --message"
			;;
		blame,--*)
			__gitcomp "--git-format"
			;;
		migrate,--*)
			__gitcomp "
				--config-dir= --ignore-paths= --minimize
				--no-auth-cache --username=
				"
			;;
		reset,--*)
			__gitcomp "--revision= --parent"
			;;
		*)
			;;
		esac
	fi
}

_git_symbolic_ref () {
	case "$cur" in
	--*)
		__gitcomp_builtin symbolic-ref
		return
		;;
	esac

	__git_complete_refs
}

_git_tag ()
{
	local i c="$__git_cmd_idx" f=0
	while [ $c -lt $cword ]; do
		i="${words[c]}"
		case "$i" in
		-d|--delete|-v|--verify)
			__gitcomp_direct "$(__git_tags "" "$cur" " ")"
			return
			;;
		-f)
			f=1
			;;
		esac
		((c++))
	done

	case "$prev" in
	-m|-F)
		;;
	-*|tag)
		if [ $f = 1 ]; then
			__gitcomp_direct "$(__git_tags "" "$cur" " ")"
		fi
		;;
	*)
		__git_complete_refs
		;;
	esac

	case "$cur" in
	--*)
		__gitcomp_builtin tag
		;;
	esac
}

_git_whatchanged ()
{
	_git_log
}

__git_complete_worktree_paths ()
{
	local IFS=$'\n'
	# Generate completion reply from worktree list skipping the first
	# entry: it's the path of the main worktree, which can't be moved,
	# removed, locked, etc.
	__gitcomp_nl "$(__git worktree list --porcelain |
		sed -n -e '2,$ s/^worktree //p')"
}

_git_worktree ()
{
	local subcommands="add list lock move prune remove unlock"
	local subcommand subcommand_idx

	subcommand="$(__git_find_on_cmdline --show-idx "$subcommands")"
	subcommand_idx="${subcommand% *}"
	subcommand="${subcommand#* }"

	case "$subcommand,$cur" in
	,*)
		__gitcomp "$subcommands"
		;;
	*,--*)
		__gitcomp_builtin worktree_$subcommand
		;;
	add,*)	# usage: git worktree add [<options>] <path> [<commit-ish>]
		# Here we are not completing an --option, it's either the
		# path or a ref.
		case "$prev" in
		-b|-B)	# Complete refs for branch to be created/reseted.
			__git_complete_refs
			;;
		-*)	# The previous word is an -o|--option without an
			# unstuck argument: have to complete the path for
			# the new worktree, so don't list anything, but let
			# Bash fall back to filename completion.
			;;
		*)	# The previous word is not an --option, so it must
			# be either the 'add' subcommand, the unstuck
			# argument of an option (e.g. branch for -b|-B), or
			# the path for the new worktree.
			if [ $cword -eq $((subcommand_idx+1)) ]; then
				# Right after the 'add' subcommand: have to
				# complete the path, so fall back to Bash
				# filename completion.
				:
			else
				case "${words[cword-2]}" in
				-b|-B)	# After '-b <branch>': have to
					# complete the path, so fall back
					# to Bash filename completion.
					;;
				*)	# After the path: have to complete
					# the ref to be checked out.
					__git_complete_refs
					;;
				esac
			fi
			;;
		esac
		;;
	lock,*|remove,*|unlock,*)
		__git_complete_worktree_paths
		;;
	move,*)
		if [ $cword -eq $((subcommand_idx+1)) ]; then
			# The first parameter must be an existing working
			# tree to be moved.
			__git_complete_worktree_paths
		else
			# The second parameter is the destination: it could
			# be any path, so don't list anything, but let Bash
			# fall back to filename completion.
			:
		fi
		;;
	esac
}

__git_complete_common () {
	local command="$1"

	case "$cur" in
	--*)
		__gitcomp_builtin "$command"
		;;
	esac
}

__git_cmds_with_parseopt_helper=
__git_support_parseopt_helper () {
	test -n "$__git_cmds_with_parseopt_helper" ||
		__git_cmds_with_parseopt_helper="$(__git --list-cmds=parseopt)"

	case " $__git_cmds_with_parseopt_helper " in
	*" $1 "*)
		return 0
		;;
	*)
		return 1
		;;
	esac
}

__git_have_func () {
	declare -f -- "$1" >/dev/null 2>&1
}

__git_complete_command () {
	local command="$1"
	local completion_func="_git_${command//-/_}"
	if ! __git_have_func $completion_func &&
		__git_have_func _completion_loader
	then
		_completion_loader "git-$command"
	fi
	if __git_have_func $completion_func
	then
		$completion_func
		return 0
	elif __git_support_parseopt_helper "$command"
	then
		__git_complete_common "$command"
		return 0
	else
		return 1
	fi
}

__git_main ()
{
	local i c=1 command __git_dir __git_repo_path
	local __git_C_args C_args_count=0
	local __git_cmd_idx

	while [ $c -lt $cword ]; do
		i="${words[c]}"
		case "$i" in
		--git-dir=*)
			__git_dir="${i#--git-dir=}"
			;;
		--git-dir)
			((c++))
			__git_dir="${words[c]}"
			;;
		--bare)
			__git_dir="."
			;;
		--help)
			command="help"
			break
			;;
		-c|--work-tree|--namespace)
			((c++))
			;;
		-C)
			__git_C_args[C_args_count++]=-C
			((c++))
			__git_C_args[C_args_count++]="${words[c]}"
			;;
		-*)
			;;
		*)
			command="$i"
			__git_cmd_idx="$c"
			break
			;;
		esac
		((c++))
	done

	if [ -z "${command-}" ]; then
		case "$prev" in
		--git-dir|-C|--work-tree)
			# these need a path argument, let's fall back to
			# Bash filename completion
			return
			;;
		-c)
			__git_complete_config_variable_name_and_value
			return
			;;
		--namespace)
			# we don't support completing these options' arguments
			return
			;;
		esac
		case "$cur" in
		--*)
			__gitcomp "
			--paginate
			--no-pager
			--git-dir=
			--bare
			--version
			--exec-path
			--exec-path=
			--html-path
			--man-path
			--info-path
			--work-tree=
			--namespace=
			--no-replace-objects
			--help
			"
			;;
		*)
			if test -n "${GIT_TESTING_PORCELAIN_COMMAND_LIST-}"
			then
				__gitcomp "$GIT_TESTING_PORCELAIN_COMMAND_LIST"
			else
				local list_cmds=list-mainporcelain,others,nohelpers,alias,list-complete,config

				if test "${GIT_COMPLETION_SHOW_ALL_COMMANDS-}" = "1"
				then
					list_cmds=builtins,$list_cmds
				fi
				__gitcomp "$(__git --list-cmds=$list_cmds)"
			fi
			;;
		esac
		return
	fi

	__git_complete_command "$command" && return

	local expansion=$(__git_aliased_command "$command")
	if [ -n "$expansion" ]; then
		words[1]=$expansion
		__git_complete_command "$expansion"
	fi
}

__gitk_main ()
{
	__git_has_doubledash && return

	local __git_repo_path
	__git_find_repo_path

	local merge=""
	if __git_pseudoref_exists MERGE_HEAD; then
		merge="--merge"
	fi
	case "$cur" in
	--*)
		__gitcomp "
			$__git_log_common_options
			$__git_log_gitk_options
			$merge
			"
		return
		;;
	esac
	__git_complete_revlist
}

if [[ -n ${ZSH_VERSION-} && -z ${GIT_SOURCING_ZSH_COMPLETION-} ]]; then
	echo "ERROR: this script is obsolete, please see git-completion.zsh" 1>&2
	return
fi

__git_func_wrap ()
{
	local cur words cword prev
	local __git_cmd_idx=0
	_get_comp_words_by_ref -n =: cur words cword prev
	$1
}

___git_complete ()
{
	local wrapper="__git_wrap${2}"
	eval "$wrapper () { __git_func_wrap $2 ; }"
	complete -o bashdefault -o default -o nospace -F $wrapper $1 2>/dev/null \
		|| complete -o default -o nospace -F $wrapper $1
}

# Setup the completion for git commands
# 1: command or alias
# 2: function to call (e.g. `git`, `gitk`, `git_fetch`)
__git_complete ()
{
	local func

	if __git_have_func $2; then
		func=$2
	elif __git_have_func __$2_main; then
		func=__$2_main
	elif __git_have_func _$2; then
		func=_$2
	else
		echo "ERROR: could not find function '$2'" 1>&2
		return 1
	fi
	___git_complete $1 $func
}

___git_complete git __git_main
___git_complete gitk __gitk_main

# The following are necessary only for Cygwin, and only are needed
# when the user has tab-completed the executable name and consequently
# included the '.exe' suffix.
#
if [ "$OSTYPE" = cygwin ]; then
	___git_complete git.exe __git_main
fi
```

`/home/setuc/.dotfiles/bash/completions/custom_env_completion.sh`:

```sh
# ~/bash/completions/custom_env_completion.sh  
  
# Custom environment completion  
_custom_env_completion() {  
    local cur=${COMP_WORDS[COMP_CWORD]}  
    local envs=()  
  
    # Add Conda environments  
    if command -v conda &> /dev/null; then  
        while IFS= read -r line; do  
            envs+=("$line")  
        done < <(conda env list | grep -v '^#' | awk '{print $1}')  
    fi  
  
    # Add virtualenv environments  
    if [ -d "$HOME/.virtualenvs" ]; then  
        while IFS= read -r line; do  
            envs+=("$line")  
        done < <(ls -1 "$HOME/.virtualenvs")  
    fi  
  
    COMPREPLY=($(compgen -W "${envs[*]}" -- "$cur"))  
}  
  
# Register custom completion for activate command  
complete -F _custom_env_completion activate  

```

`/home/setuc/.dotfiles/bash/completions/docker-completion.bash`:

```bash
#!/usr/bin/env bash
# shellcheck disable=SC2016,SC2119,SC2155,SC2206,SC2207,SC2254
#
# Shellcheck ignore list:
#  - SC2016: Expressions don't expand in single quotes, use double quotes for that.
#  - SC2119: Use foo "$@" if function's $1 should mean script's $1.
#  - SC2155: Declare and assign separately to avoid masking return values.
#  - SC2206: Quote to prevent word splitting, or split robustly with mapfile or read -a.
#  - SC2207: Prefer mapfile or read -a to split command output (or quote to avoid splitting).
#  - SC2254: Quote expansions in case patterns to match literally rather than as a glob.
#
# You can find more details for each warning at the following page:
#    https://github.com/koalaman/shellcheck/wiki/<SCXXXX>
#
# bash completion file for core docker commands
#
# This script provides completion of:
#  - commands and their options
#  - container ids and names
#  - image repos and tags
#  - filepaths
#
# To enable the completions either:
#  - place this file in /etc/bash_completion.d
#  or
#  - copy this file to e.g. ~/.docker-completion.sh and add the line
#    below to your .bashrc after bash completion features are loaded
#    . ~/.docker-completion.sh
#
# Configuration:
#
# For several commands, the amount of completions can be configured by
# setting environment variables.
#
# DOCKER_COMPLETION_SHOW_CONFIG_IDS
# DOCKER_COMPLETION_SHOW_CONTAINER_IDS
# DOCKER_COMPLETION_SHOW_NETWORK_IDS
# DOCKER_COMPLETION_SHOW_NODE_IDS
# DOCKER_COMPLETION_SHOW_PLUGIN_IDS
# DOCKER_COMPLETION_SHOW_SECRET_IDS
# DOCKER_COMPLETION_SHOW_SERVICE_IDS
#   "no"  - Show names only (default)
#   "yes" - Show names and ids
#
# You can tailor completion for the "events", "history", "inspect", "run",
# "rmi" and "save" commands by setting the following environment
# variables:
#
# DOCKER_COMPLETION_SHOW_IMAGE_IDS
#   "none" - Show names only (default)
#   "non-intermediate" - Show names and ids, but omit intermediate image IDs
#   "all" - Show names and ids, including intermediate image IDs
#
# DOCKER_COMPLETION_SHOW_TAGS
#   "yes" - include tags in completion options (default)
#   "no"  - don't include tags in completion options

#
# Note:
# Currently, the completions will not work if the docker daemon is not
# bound to the default communication port/socket
# If the docker daemon is using a unix socket for communication your user
# must have access to the socket for the completions to function correctly
#
# Note for developers:
# Arrange options sorted alphabetically by long name with the short
# options immediately following their corresponding long form.
# This order should be applied to lists, alternatives and code blocks.

__docker_previous_extglob_setting=$(shopt -p extglob)
shopt -s extglob

__docker_q() {
	docker ${host:+--host "$host"} ${config:+--config "$config"} ${context:+--context "$context"} 2>/dev/null "$@"
}

# __docker_configs returns a list of configs. Additional options to
# `docker config ls` may be specified in order to filter the list, e.g.
# `__docker_configs --filter label=stage=production`.
# By default, only names are returned.
# Set DOCKER_COMPLETION_SHOW_CONFIG_IDS=yes to also complete IDs.
# An optional first option `--id|--name` may be used to limit the
# output to the IDs or names of matching items. This setting takes
# precedence over the environment setting.
__docker_configs() {
	local format
	if [ "${1-}" = "--id" ] ; then
		format='{{.ID}}'
		shift
	elif [ "${1-}" = "--name" ] ; then
		format='{{.Name}}'
		shift
	elif [ "${DOCKER_COMPLETION_SHOW_CONFIG_IDS-}" = yes ] ; then
		format='{{.ID}} {{.Name}}'
	else
		format='{{.Name}}'
	fi

	__docker_q config ls --format "$format" "$@"
}

# __docker_complete_configs applies completion of configs based on the current value
# of `$cur` or the value of the optional first option `--cur`, if given.
__docker_complete_configs() {
	local current="$cur"
	if [ "$1" = "--cur" ] ; then
		current="$2"
		shift 2
	fi
	COMPREPLY=( $(compgen -W "$(__docker_configs "$@")" -- "$current") )
}

# __docker_containers returns a list of containers. Additional options to
# `docker ps` may be specified in order to filter the list, e.g.
# `__docker_containers --filter status=running`
# By default, only names are returned.
# Set DOCKER_COMPLETION_SHOW_CONTAINER_IDS=yes to also complete IDs.
# An optional first option `--id|--name` may be used to limit the
# output to the IDs or names of matching items. This setting takes
# precedence over the environment setting.
__docker_containers() {
	local format
	if [ "${1-}" = "--id" ] ; then
		format='{{.ID}}'
		shift
	elif [ "${1-}" = "--name" ] ; then
		format='{{.Names}}'
		shift
	elif [ "${DOCKER_COMPLETION_SHOW_CONTAINER_IDS-}" = yes ] ; then
		format='{{.ID}} {{.Names}}'
	else
		format='{{.Names}}'
	fi
	__docker_q ps --format "$format" "$@"
}

# __docker_complete_containers applies completion of containers based on the current
# value of `$cur` or the value of the optional first option `--cur`, if given.
# Additional filters may be appended, see `__docker_containers`.
__docker_complete_containers() {
	local current="$cur"
	if [ "${1-}" = "--cur" ] ; then
		current="$2"
		shift 2
	fi
	COMPREPLY=( $(compgen -W "$(__docker_containers "$@")" -- "$current") )
}

__docker_complete_containers_all() {
	__docker_complete_containers "$@" --all
}

# shellcheck disable=SC2120
__docker_complete_containers_removable() {
	__docker_complete_containers "$@" --filter status=created --filter status=exited
}

__docker_complete_containers_running() {
	__docker_complete_containers "$@" --filter status=running
}

# shellcheck disable=SC2120
__docker_complete_containers_stoppable() {
	__docker_complete_containers "$@" --filter status=running --filter status=paused
}

# shellcheck disable=SC2120
__docker_complete_containers_stopped() {
	__docker_complete_containers "$@" --filter status=exited
}

# shellcheck disable=SC2120
__docker_complete_containers_unpauseable() {
	__docker_complete_containers "$@" --filter status=paused
}

__docker_complete_container_names() {
	local containers=( $(__docker_q ps -aq --no-trunc) )
	local names=( $(__docker_q inspect --format '{{.Name}}' "${containers[@]}") )
	names=( "${names[@]#/}" ) # trim off the leading "/" from the container names
	COMPREPLY=( $(compgen -W "${names[*]}" -- "$cur") )
}

__docker_complete_container_ids() {
	local containers=( $(__docker_q ps -aq) )
	COMPREPLY=( $(compgen -W "${containers[*]}" -- "$cur") )
}

# __docker_contexts returns a list of contexts without the special "default" context.
# Completions may be added with `--add`, e.g. `--add default`.
__docker_contexts() {
	local add=()
	while true ; do
		case "${1-}" in
			--add)
				add+=("$2")
				shift 2
				;;
			*)
				break
				;;
		esac
	done
	__docker_q context ls -q
	echo "${add[@]}"
}

__docker_complete_contexts() {
	local contexts=( $(__docker_contexts "$@") )
	COMPREPLY=( $(compgen -W "${contexts[*]}" -- "$cur") )
}


# __docker_images returns a list of images. For each image, up to three representations
# can be generated: the repository (e.g. busybox), repository:tag (e.g. busybox:latest)
# and the ID (e.g. sha256:ee22cbbd4ea3dff63c86ba60c7691287c321e93adfc1009604eb1dde7ec88645).
#
# The optional arguments `--repo`, `--tag` and `--id` select the representations that
# may be returned. Whether or not a particular representation is actually returned
# depends on the user's customization through several environment variables:
# - image IDs are only shown if DOCKER_COMPLETION_SHOW_IMAGE_IDS=all|non-intermediate.
# - tags can be excluded by setting DOCKER_COMPLETION_SHOW_TAGS=no.
# - repositories are always shown.
#
# In cases where an exact image specification is needed, `--force-tag` can be used.
# It ignores DOCKER_COMPLETION_SHOW_TAGS and only lists valid repository:tag combinations,
# avoiding repository names that would default to a potentially missing default tag.
#
# Additional arguments to `docker image ls` may be specified in order to filter the list,
# e.g. `__docker_images --filter dangling=true`.
#
__docker_images() {
	local repo_format='{{.Repository}}'
	local tag_format='{{.Repository}}:{{.Tag}}'
	local id_format='{{.ID}}'
	local all
	local format

	if [ "${DOCKER_COMPLETION_SHOW_IMAGE_IDS-}" = "all" ] ; then
		all='--all'
	fi

	while true ; do
		case "${1-}" in
			--repo)
				format+="$repo_format\n"
				shift
				;;
			--tag)
				if [ "${DOCKER_COMPLETION_SHOW_TAGS:-yes}" = "yes" ]; then
					format+="$tag_format\n"
				fi
				shift
				;;
			--id)
				if [[ ${DOCKER_COMPLETION_SHOW_IMAGE_IDS-} =~ ^(all|non-intermediate)$ ]] ; then
					format+="$id_format\n"
				fi
				shift
				;;
			--force-tag)
				# like `--tag` but ignores environment setting
				format+="$tag_format\n"
				shift
				;;
			*)
				break
				;;
		esac
	done

	__docker_q image ls --no-trunc --format "${format%\\n}" ${all-} "$@" | grep -v '<none>$'
}

# __docker_complete_images applies completion of images based on the current value of `$cur` or
# the value of the optional first option `--cur`, if given.
# See __docker_images for customization of the returned items.
__docker_complete_images() {
	local current="$cur"
	if [ "${1-}" = "--cur" ] ; then
		current="$2"
		shift 2
	fi
	COMPREPLY=( $(compgen -W "$(__docker_images "$@")" -- "$current") )
	__ltrim_colon_completions "$current"
}

# __docker_networks returns a list of all networks. Additional options to
# `docker network ls` may be specified in order to filter the list, e.g.
# `__docker_networks --filter type=custom`
# By default, only names are returned.
# Set DOCKER_COMPLETION_SHOW_NETWORK_IDS=yes to also complete IDs.
# An optional first option `--id|--name` may be used to limit the
# output to the IDs or names of matching items. This setting takes
# precedence over the environment setting.
__docker_networks() {
	local format
	if [ "${1-}" = "--id" ] ; then
		format='{{.ID}}'
		shift
	elif [ "${1-}" = "--name" ] ; then
		format='{{.Name}}'
		shift
	elif [ "${DOCKER_COMPLETION_SHOW_NETWORK_IDS-}" = yes ] ; then
		format='{{.ID}} {{.Name}}'
	else
		format='{{.Name}}'
	fi
	__docker_q network ls --format "$format" "$@"
}

# __docker_complete_networks applies completion of networks based on the current
# value of `$cur` or the value of the optional first option `--cur`, if given.
# Additional filters may be appended, see `__docker_networks`.
__docker_complete_networks() {
	local current="$cur"
	if [ "${1-}" = "--cur" ] ; then
		current="$2"
		shift 2
	fi
	COMPREPLY=( $(compgen -W "$(__docker_networks "$@")" -- "$current") )
}

__docker_complete_containers_in_network() {
	local containers=($(__docker_q network inspect -f '{{range $i, $c := .Containers}}{{$i}} {{$c.Name}} {{end}}' "$1"))
	COMPREPLY=( $(compgen -W "${containers[*]}" -- "$cur") )
}

# __docker_volumes returns a list of all volumes. Additional options to
# `docker volume ls` may be specified in order to filter the list, e.g.
# `__docker_volumes --filter dangling=true`
# Because volumes do not have IDs, this function does not distinguish between
# IDs and names.
__docker_volumes() {
	__docker_q volume ls -q "$@"
}

# __docker_complete_volumes applies completion of volumes based on the current
# value of `$cur` or the value of the optional first option `--cur`, if given.
# Additional filters may be appended, see `__docker_volumes`.
__docker_complete_volumes() {
	local current="$cur"
	if [ "${1-}" = "--cur" ] ; then
		current="$2"
		shift 2
	fi
	COMPREPLY=( $(compgen -W "$(__docker_volumes "$@")" -- "$current") )
}

# __docker_plugins_bundled returns a list of all plugins of a given type.
# The type has to be specified with the mandatory option `--type`.
# Valid types are: Network, Volume, Authorization.
# Completions may be added or removed with `--add` and `--remove`
# This function only deals with plugins that come bundled with Docker.
# For plugins managed by `docker plugin`, see `__docker_plugins_installed`.
__docker_plugins_bundled() {
	local type add=() remove=()
	while true ; do
		case "${1-}" in
			--type)
				type="$2"
				shift 2
				;;
			--add)
				add+=("$2")
				shift 2
				;;
			--remove)
				remove+=("$2")
				shift 2
				;;
			*)
				break
				;;
		esac
	done

	local plugins=($(__docker_q info --format "{{range \$i, \$p := .Plugins.$type}}{{.}} {{end}}"))
	for del in "${remove[@]}" ; do
		plugins=(${plugins[@]/$del/})
	done
	echo "${plugins[@]}" "${add[@]}"
}

# __docker_complete_plugins_bundled applies completion of plugins based on the current
# value of `$cur` or the value of the optional first option `--cur`, if given.
# The plugin type has to be specified with the next option `--type`.
# This function only deals with plugins that come bundled with Docker.
# For completion of plugins managed by `docker plugin`, see
# `__docker_complete_plugins_installed`.
__docker_complete_plugins_bundled() {
	local current="$cur"
	if [ "${1-}" = "--cur" ] ; then
		current="$2"
		shift 2
	fi
	COMPREPLY=( $(compgen -W "$(__docker_plugins_bundled "$@")" -- "$current") )
}

# __docker_plugins_installed returns a list of all plugins that were installed with
# the Docker plugin API.
# By default, only names are returned.
# Set DOCKER_COMPLETION_SHOW_PLUGIN_IDS=yes to also complete IDs.
# Additional options to `docker plugin ls` may be specified in order to filter the list,
# e.g. `__docker_plugins_installed --filter enabled=true`
# For built-in pugins, see `__docker_plugins_bundled`.
__docker_plugins_installed() {
	local format
	if [ "${DOCKER_COMPLETION_SHOW_PLUGIN_IDS-}" = yes ] ; then
		format='{{.ID}} {{.Name}}'
	else
		format='{{.Name}}'
	fi
	__docker_q plugin ls --format "$format" "$@"
}

# __docker_complete_plugins_installed applies completion of plugins that were installed
# with the Docker plugin API, based on the current value of `$cur` or the value of
# the optional first option `--cur`, if given.
# Additional filters may be appended, see `__docker_plugins_installed`.
# For completion of built-in pugins, see `__docker_complete_plugins_bundled`.
__docker_complete_plugins_installed() {
	local current="$cur"
	if [ "${1-}" = "--cur" ] ; then
		current="$2"
		shift 2
	fi
	COMPREPLY=( $(compgen -W "$(__docker_plugins_installed "$@")" -- "$current") )
}

__docker_runtimes() {
	__docker_q info | sed -n 's/^Runtimes: \(.*\)/\1/p'
}

__docker_complete_runtimes() {
	COMPREPLY=( $(compgen -W "$(__docker_runtimes)" -- "$cur") )
}

# __docker_secrets returns a list of secrets. Additional options to
# `docker secret ls` may be specified in order to filter the list, e.g.
# `__docker_secrets --filter label=stage=production`
# By default, only names are returned.
# Set DOCKER_COMPLETION_SHOW_SECRET_IDS=yes to also complete IDs.
# An optional first option `--id|--name` may be used to limit the
# output to the IDs or names of matching items. This setting takes
# precedence over the environment setting.
__docker_secrets() {
	local format
	if [ "${1-}" = "--id" ] ; then
		format='{{.ID}}'
		shift
	elif [ "${1-}" = "--name" ] ; then
		format='{{.Name}}'
		shift
	elif [ "${DOCKER_COMPLETION_SHOW_SECRET_IDS-}" = yes ] ; then
		format='{{.ID}} {{.Name}}'
	else
		format='{{.Name}}'
	fi

	__docker_q secret ls --format "$format" "$@"
}

# __docker_complete_secrets applies completion of secrets based on the current value
# of `$cur` or the value of the optional first option `--cur`, if given.
__docker_complete_secrets() {
	local current="$cur"
	if [ "${1-}" = "--cur" ] ; then
		current="$2"
		shift 2
	fi
	COMPREPLY=( $(compgen -W "$(__docker_secrets "$@")" -- "$current") )
}

# __docker_stacks returns a list of all stacks.
__docker_stacks() {
	__docker_q stack ls | awk 'NR>1 {print $1}'
}

# __docker_complete_stacks applies completion of stacks based on the current value
# of `$cur` or the value of the optional first option `--cur`, if given.
__docker_complete_stacks() {
	local current="$cur"
	if [ "${1-}" = "--cur" ] ; then
		current="$2"
		shift 2
	fi
	COMPREPLY=( $(compgen -W "$(__docker_stacks "$@")" -- "$current") )
}

# __docker_nodes returns a list of all nodes. Additional options to
# `docker node ls` may be specified in order to filter the list, e.g.
# `__docker_nodes --filter role=manager`
# By default, only node names are returned.
# Set DOCKER_COMPLETION_SHOW_NODE_IDS=yes to also complete node IDs.
# An optional first option `--id|--name` may be used to limit the
# output to the IDs or names of matching items. This setting takes
# precedence over the environment setting.
# Completions may be added with `--add`, e.g. `--add self`.
__docker_nodes() {
	local format
	if [ "${DOCKER_COMPLETION_SHOW_NODE_IDS-}" = yes ] ; then
		format='{{.ID}} {{.Hostname}}'
	else
		format='{{.Hostname}}'
	fi

	local add=()

	while true ; do
		case "${1-}" in
			--id)
				format='{{.ID}}'
				shift
				;;
			--name)
				format='{{.Hostname}}'
				shift
				;;
			--add)
				add+=("$2")
				shift 2
				;;
			*)
				break
				;;
		esac
	done

	echo "$(__docker_q node ls --format "$format" "$@")" "${add[@]}"
}

# __docker_complete_nodes applies completion of nodes based on the current
# value of `$cur` or the value of the optional first option `--cur`, if given.
# Additional filters may be appended, see `__docker_nodes`.
__docker_complete_nodes() {
	local current="$cur"
	if [ "${1-}" = "--cur" ] ; then
		current="$2"
		shift 2
	fi
	COMPREPLY=( $(compgen -W "$(__docker_nodes "$@")" -- "$current") )
}

# __docker_services returns a list of all services. Additional options to
# `docker service ls` may be specified in order to filter the list, e.g.
# `__docker_services --filter name=xxx`
# By default, only node names are returned.
# Set DOCKER_COMPLETION_SHOW_SERVICE_IDS=yes to also complete IDs.
# An optional first option `--id|--name` may be used to limit the
# output to the IDs or names of matching items. This setting takes
# precedence over the environment setting.
__docker_services() {
	local format='{{.Name}}'  # default: service name only
	[ "${DOCKER_COMPLETION_SHOW_SERVICE_IDS-}" = yes ] && format='{{.ID}} {{.Name}}' # ID & name

	if [ "${1-}" = "--id" ] ; then
		format='{{.ID}}' # IDs only
		shift
	elif [ "${1-}" = "--name" ] ; then
		format='{{.Name}}' # names only
		shift
	fi

	__docker_q service ls --quiet --format "$format" "$@"
}

# __docker_complete_services applies completion of services based on the current
# value of `$cur` or the value of the optional first option `--cur`, if given.
# Additional filters may be appended, see `__docker_services`.
__docker_complete_services() {
	local current="$cur"
	if [ "${1-}" = "--cur" ] ; then
		current="$2"
		shift 2
	fi
	COMPREPLY=( $(__docker_services "$@" --filter "name=$current") )
}

# __docker_tasks returns a list of all task IDs.
__docker_tasks() {
	__docker_q service ps --format '{{.ID}}' ""
}

# __docker_complete_services_and_tasks applies completion of services and task IDs.
# shellcheck disable=SC2120
__docker_complete_services_and_tasks() {
	COMPREPLY=( $(compgen -W "$(__docker_services "$@") $(__docker_tasks)" -- "$cur") )
}

# __docker_append_to_completions appends the word passed as an argument to every
# word in `$COMPREPLY`.
# Normally you do this with `compgen -S` while generating the completions.
# This function allows you to append a suffix later. It allows you to use
# the __docker_complete_XXX functions in cases where you need a suffix.
__docker_append_to_completions() {
	COMPREPLY=( ${COMPREPLY[@]/%/"$1"} )
}

# __docker_fetch_info fetches information about the configured Docker server and updates
# several variables with the results.
# The result is cached for the duration of one invocation of bash completion.
__docker_fetch_info() {
	if [ -z "${info_fetched-}" ] ; then
		read -r server_experimental server_os <<< "$(__docker_q version -f '{{.Server.Experimental}} {{.Server.Os}}')"
		info_fetched=true
	fi
}

# __docker_server_is_experimental tests whether the currently configured Docker
# server runs in experimental mode. If so, the function exits with 0 (true).
# Otherwise, or if the result cannot be determined, the exit value is 1 (false).
__docker_server_is_experimental() {
	__docker_fetch_info
	[ "$server_experimental" = "true" ]
}

# __docker_server_os_is tests whether the currently configured Docker server runs
# on the operating system passed in as the first argument.
# Known operating systems: linux, windows.
__docker_server_os_is() {
	local expected_os="$1"
	__docker_fetch_info
	[ "$server_os" = "$expected_os" ]
}

# __docker_pos_first_nonflag finds the position of the first word that is neither
# option nor an option's argument. If there are options that require arguments,
# you should pass a glob describing those options, e.g. "--option1|-o|--option2"
# Use this function to restrict completions to exact positions after the argument list.
__docker_pos_first_nonflag() {
	local argument_flags=${1-}

	local counter=$((${subcommand_pos:-${command_pos}} + 1))
	while [ "$counter" -le "$cword" ]; do
		if [ -n "$argument_flags" ] && eval "case '${words[$counter]}' in $argument_flags) true ;; *) false ;; esac"; then
			(( counter++ ))
			# eat "=" in case of --option=arg syntax
			[ "${words[$counter]}" = "=" ] && (( counter++ ))
		else
			case "${words[$counter]}" in
				-*)
					;;
				*)
					break
					;;
			esac
		fi

		# Bash splits words at "=", retaining "=" as a word, examples:
		# "--debug=false" => 3 words, "--log-opt syslog-facility=daemon" => 4 words
		while [ "${words[$counter + 1]}" = "=" ] ; do
			counter=$(( counter + 2))
		done

		(( counter++ ))
	done

	echo "$counter"
}

# __docker_map_key_of_current_option returns `key` if we are currently completing the
# value of a map option (`key=value`) which matches the extglob given as an argument.
# This function is needed for key-specific completions.
__docker_map_key_of_current_option() {
	local glob="$1"

	local key glob_pos
	if [ "$cur" = "=" ] ; then        # key= case
		key="$prev"
		glob_pos=$((cword - 2))
	elif [[ $cur == *=* ]] ; then     # key=value case (OSX)
		key=${cur%=*}
		glob_pos=$((cword - 1))
	elif [ "$prev" = "=" ] ; then
		key=${words[$cword - 2]}  # key=value case
		glob_pos=$((cword - 3))
	else
		return
	fi

	[ "${words[$glob_pos]}" = "=" ] && ((glob_pos--))  # --option=key=value syntax

	[[ ${words[$glob_pos]} == @($glob) ]] && echo "$key"
}

# __docker_value_of_option returns the value of the first option matching `option_glob`.
# Valid values for `option_glob` are option names like `--log-level` and globs like
# `--log-level|-l`
# Only positions between the command and the current word are considered.
__docker_value_of_option() {
	local option_extglob=$(__docker_to_extglob "$1")

	local counter=$((command_pos + 1))
	while [ "$counter" -lt "$cword" ]; do
		case ${words[$counter]} in
			$option_extglob )
				echo "${words[$counter + 1]}"
				break
				;;
		esac
		(( counter++ ))
	done
}

# __docker_to_alternatives transforms a multiline list of strings into a single line
# string with the words separated by `|`.
# This is used to prepare arguments to __docker_pos_first_nonflag().
__docker_to_alternatives() {
	local parts=( $1 )
	local IFS='|'
	echo "${parts[*]}"
}

# __docker_to_extglob transforms a multiline list of options into an extglob pattern
# suitable for use in case statements.
__docker_to_extglob() {
	local extglob=$( __docker_to_alternatives "$1" )
	echo "@($extglob)"
}

# __docker_subcommands processes subcommands
# Locates the first occurrence of any of the subcommands contained in the
# first argument. In case of a match, calls the corresponding completion
# function and returns 0.
# If no match is found, 1 is returned. The calling function can then
# continue processing its completion.
#
# TODO if the preceding command has options that accept arguments and an
# argument is equal ot one of the subcommands, this is falsely detected as
# a match.
__docker_subcommands() {
	local subcommands="$1"

	local counter=$((command_pos + 1))
	while [ "$counter" -lt "$cword" ]; do
		case "${words[$counter]}" in
			$(__docker_to_extglob "$subcommands") )
				subcommand_pos=$counter
				local subcommand=${words[$counter]}
				local completions_func=_docker_${command}_${subcommand//-/_}
				declare -F "$completions_func" >/dev/null && "$completions_func"
				return 0
				;;
		esac
		(( counter++ ))
	done
	return 1
}

# __docker_nospace suppresses trailing whitespace
__docker_nospace() {
	# compopt is not available in ancient bash versions
	type compopt &>/dev/null && compopt -o nospace
}

__docker_complete_resolved_hostname() {
	command -v host >/dev/null 2>&1 || return
	COMPREPLY=( $(host 2>/dev/null "${cur%:}" | awk '/has address/ {print $4}') )
}

# __docker_local_interfaces returns a list of the names and addresses of all
# local network interfaces.
# If `--ip-only` is passed as a first argument, only addresses are returned.
__docker_local_interfaces() {
	command -v ip >/dev/null 2>&1 || return

	local format
	if [ "${1-}" = "--ip-only" ] ; then
		format='\1'
		shift
	else
		 format='\1 \2'
	fi

	ip addr show scope global 2>/dev/null | sed -n "s| \+inet \([0-9.]\+\).* \([^ ]\+\)|$format|p"
}

# __docker_complete_local_interfaces applies completion of the names and addresses of all
# local network interfaces based on the current value of `$cur`.
# An additional value can be added to the possible completions with an `--add` argument.
__docker_complete_local_interfaces() {
	local additional_interface
	if [ "${1-}" = "--add" ] ; then
		additional_interface="$2"
		shift 2
	fi

	COMPREPLY=( $( compgen -W "$(__docker_local_interfaces "$@") $additional_interface" -- "$cur" ) )
}

# __docker_complete_local_ips applies completion of the addresses of all local network
# interfaces based on the current value of `$cur`.
__docker_complete_local_ips() {
	__docker_complete_local_interfaces --ip-only
}

# __docker_complete_capabilities_addable completes Linux capabilities which are
# not granted by default and may be added.
# see https://docs.docker.com/engine/reference/run/#/runtime-privilege-and-linux-capabilities
__docker_complete_capabilities_addable() {
  local capabilities=(
		ALL
		CAP_AUDIT_CONTROL
		CAP_AUDIT_READ
		CAP_BLOCK_SUSPEND
		CAP_BPF
		CAP_CHECKPOINT_RESTORE
		CAP_DAC_READ_SEARCH
		CAP_IPC_LOCK
		CAP_IPC_OWNER
		CAP_LEASE
		CAP_LINUX_IMMUTABLE
		CAP_MAC_ADMIN
		CAP_MAC_OVERRIDE
		CAP_NET_ADMIN
		CAP_NET_BROADCAST
		CAP_PERFMON
		CAP_SYS_ADMIN
		CAP_SYS_BOOT
		CAP_SYSLOG
		CAP_SYS_MODULE
		CAP_SYS_NICE
		CAP_SYS_PACCT
		CAP_SYS_PTRACE
		CAP_SYS_RAWIO
		CAP_SYS_RESOURCE
		CAP_SYS_TIME
		CAP_SYS_TTY_CONFIG
		CAP_WAKE_ALARM
		RESET
  )
	COMPREPLY=( $( compgen -W "${capabilities[*]} ${capabilities[*]#CAP_}" -- "$cur" ) )
}

# __docker_complete_capabilities_droppable completes Linux capability options which are
# allowed by default and can be dropped.
# see https://docs.docker.com/engine/reference/run/#/runtime-privilege-and-linux-capabilities
__docker_complete_capabilities_droppable() {
	local capabilities=(
		ALL
		CAP_AUDIT_WRITE
		CAP_CHOWN
		CAP_DAC_OVERRIDE
		CAP_FOWNER
		CAP_FSETID
		CAP_KILL
		CAP_MKNOD
		CAP_NET_BIND_SERVICE
		CAP_NET_RAW
		CAP_SETFCAP
		CAP_SETGID
		CAP_SETPCAP
		CAP_SETUID
		CAP_SYS_CHROOT
		RESET
	)
	COMPREPLY=( $( compgen -W "${capabilities[*]} ${capabilities[*]#CAP_}" -- "$cur" ) )
}

__docker_complete_detach_keys() {
	case "$prev" in
		--detach-keys)
			case "$cur" in
				*,)
					COMPREPLY=( $( compgen -W "${cur}ctrl-" -- "$cur" ) )
					;;
				*)
					COMPREPLY=( $( compgen -W "ctrl-" -- "$cur" ) )
					;;
			esac

			__docker_nospace
			return
			;;
	esac
	return 1
}

__docker_complete_isolation() {
	COMPREPLY=( $( compgen -W "default hyperv process" -- "$cur" ) )
}

__docker_complete_log_drivers() {
	COMPREPLY=( $( compgen -W "
		awslogs
		etwlogs
		fluentd
		gcplogs
		gelf
		journald
		json-file
		local
		none
		splunk
		syslog
	" -- "$cur" ) )
}

__docker_complete_log_options() {
	# see https://docs.docker.com/config/containers/logging/configure/

	# really global options, defined in https://github.com/moby/moby/blob/master/daemon/logger/factory.go
	local common_options1="max-buffer-size mode"
	# common options defined in https://github.com/moby/moby/blob/master/daemon/logger/loginfo.go
	# but not implemented in all log drivers
	local common_options2="env env-regex labels"

	# awslogs does not implement the $common_options2.
	local awslogs_options="$common_options1 awslogs-create-group awslogs-credentials-endpoint awslogs-datetime-format awslogs-group awslogs-multiline-pattern awslogs-region awslogs-stream tag"

	local fluentd_options="$common_options1 $common_options2 fluentd-address fluentd-async fluentd-buffer-limit fluentd-request-ack fluentd-retry-wait fluentd-max-retries fluentd-sub-second-precision tag"
	local gcplogs_options="$common_options1 $common_options2 gcp-log-cmd gcp-meta-id gcp-meta-name gcp-meta-zone gcp-project"
	local gelf_options="$common_options1 $common_options2 gelf-address gelf-compression-level gelf-compression-type gelf-tcp-max-reconnect gelf-tcp-reconnect-delay tag"
	local journald_options="$common_options1 $common_options2 tag"
	local json_file_options="$common_options1 $common_options2 compress max-file max-size"
	local local_options="$common_options1 compress max-file max-size"
	local splunk_options="$common_options1 $common_options2 splunk-caname splunk-capath splunk-format splunk-gzip splunk-gzip-level splunk-index splunk-insecureskipverify splunk-source splunk-sourcetype splunk-token splunk-url splunk-verify-connection tag"
	local syslog_options="$common_options1 $common_options2 syslog-address syslog-facility syslog-format syslog-tls-ca-cert syslog-tls-cert syslog-tls-key syslog-tls-skip-verify tag"

	local all_options="$fluentd_options $gcplogs_options $gelf_options $journald_options $json_file_options $syslog_options $splunk_options"

	case $(__docker_value_of_option --log-driver) in
		'')
			COMPREPLY=( $( compgen -W "$all_options" -S = -- "$cur" ) )
			;;
		awslogs)
			COMPREPLY=( $( compgen -W "$awslogs_options" -S = -- "$cur" ) )
			;;
		fluentd)
			COMPREPLY=( $( compgen -W "$fluentd_options" -S = -- "$cur" ) )
			;;
		gcplogs)
			COMPREPLY=( $( compgen -W "$gcplogs_options" -S = -- "$cur" ) )
			;;
		gelf)
			COMPREPLY=( $( compgen -W "$gelf_options" -S = -- "$cur" ) )
			;;
		journald)
			COMPREPLY=( $( compgen -W "$journald_options" -S = -- "$cur" ) )
			;;
		json-file)
			COMPREPLY=( $( compgen -W "$json_file_options" -S = -- "$cur" ) )
			;;
		local)
			COMPREPLY=( $( compgen -W "$local_options" -S = -- "$cur" ) )
			;;
		syslog)
			COMPREPLY=( $( compgen -W "$syslog_options" -S = -- "$cur" ) )
			;;
		splunk)
			COMPREPLY=( $( compgen -W "$splunk_options" -S = -- "$cur" ) )
			;;
		*)
			return
			;;
	esac

	__docker_nospace
}

__docker_complete_log_driver_options() {
	local key=$(__docker_map_key_of_current_option '--log-opt')
	case "$key" in
		awslogs-create-group)
			COMPREPLY=( $( compgen -W "false true" -- "${cur##*=}" ) )
			return
			;;
		awslogs-credentials-endpoint)
			COMPREPLY=( $( compgen -W "/" -- "${cur##*=}" ) )
			__docker_nospace
			return
			;;
		compress|fluentd-async-connect)
			COMPREPLY=( $( compgen -W "false true" -- "${cur##*=}" ) )
			return
			;;
		fluentd-sub-second-precision)
			COMPREPLY=( $( compgen -W "false true" -- "${cur##*=}" ) )
			return
			;;
		gelf-address)
			COMPREPLY=( $( compgen -W "tcp udp" -S "://" -- "${cur##*=}" ) )
			__docker_nospace
			return
			;;
		gelf-compression-level)
			COMPREPLY=( $( compgen -W "1 2 3 4 5 6 7 8 9" -- "${cur##*=}" ) )
			return
			;;
		gelf-compression-type)
			COMPREPLY=( $( compgen -W "gzip none zlib" -- "${cur##*=}" ) )
			return
			;;
		line-only)
			COMPREPLY=( $( compgen -W "false true" -- "${cur##*=}" ) )
			return
			;;
		mode)
			COMPREPLY=( $( compgen -W "blocking non-blocking" -- "${cur##*=}" ) )
			return
			;;
		syslog-address)
			COMPREPLY=( $( compgen -W "tcp:// tcp+tls:// udp:// unix://" -- "${cur##*=}" ) )
			__docker_nospace
			__ltrim_colon_completions "${cur}"
			return
			;;
		syslog-facility)
			COMPREPLY=( $( compgen -W "
				auth
				authpriv
				cron
				daemon
				ftp
				kern
				local0
				local1
				local2
				local3
				local4
				local5
				local6
				local7
				lpr
				mail
				news
				syslog
				user
				uucp
			" -- "${cur##*=}" ) )
			return
			;;
		syslog-format)
			COMPREPLY=( $( compgen -W "rfc3164 rfc5424 rfc5424micro" -- "${cur##*=}" ) )
			return
			;;
		syslog-tls-ca-cert|syslog-tls-cert|syslog-tls-key)
			_filedir
			return
			;;
		syslog-tls-skip-verify)
			COMPREPLY=( $( compgen -W "true" -- "${cur##*=}" ) )
			return
			;;
		splunk-url)
			COMPREPLY=( $( compgen -W "http:// https://" -- "${cur##*=}" ) )
			__docker_nospace
			__ltrim_colon_completions "${cur}"
			return
			;;
		splunk-gzip|splunk-insecureskipverify|splunk-verify-connection)
			COMPREPLY=( $( compgen -W "false true" -- "${cur##*=}" ) )
			return
			;;
		splunk-format)
			COMPREPLY=( $( compgen -W "inline json raw" -- "${cur##*=}" ) )
			return
			;;
	esac
	return 1
}

__docker_complete_log_levels() {
	COMPREPLY=( $( compgen -W "debug info warn error fatal" -- "$cur" ) )
}

__docker_complete_restart() {
	case "$prev" in
		--restart)
			case "$cur" in
				on-failure:*)
					;;
				*)
					COMPREPLY=( $( compgen -W "always no on-failure on-failure: unless-stopped" -- "$cur") )
					;;
			esac
			return
			;;
	esac
	return 1
}

# __docker_complete_signals returns a subset of the available signals that is most likely
# relevant in the context of docker containers
__docker_complete_signals() {
	local signals=(
		SIGCONT
		SIGHUP
		SIGINT
		SIGKILL
		SIGQUIT
		SIGSTOP
		SIGTERM
		SIGUSR1
		SIGUSR2
	)
	COMPREPLY=( $( compgen -W "${signals[*]} ${signals[*]#SIG}" -- "$( echo "$cur" | tr '[:lower:]' '[:upper:]')" ) )
}

__docker_complete_ulimits() {
	local limits="
		as
		chroot
		core
		cpu
		data
		fsize
		locks
		maxlogins
		maxsyslogins
		memlock
		msgqueue
		nice
		nofile
		nproc
		priority
		rss
		rtprio
		sigpending
		stack
	"
	if [ "${1-}" = "--rm" ] ; then
		COMPREPLY=( $( compgen -W "$limits" -- "$cur" ) )
	else
		COMPREPLY=( $( compgen -W "$limits" -S = -- "$cur" ) )
		__docker_nospace
	fi
}

__docker_complete_user_group() {
	if [[ $cur == *:* ]] ; then
		COMPREPLY=( $(compgen -g -- "${cur#*:}") )
	else
		COMPREPLY=( $(compgen -u -S : -- "$cur") )
		__docker_nospace
	fi
}

__docker_plugins_path() {
	local docker_plugins_path=$(docker info --format '{{range .ClientInfo.Plugins}}{{.Path}}:{{end}}')
	echo "${docker_plugins_path//:/ }"
}

__docker_complete_plugin() {
	local path=$1
	local completionCommand="__completeNoDesc"
	local resultArray=($path $completionCommand)
	local current="$cur"
	for value in "${words[@]:2}"; do
		if [ -z "$value" ]; then
			resultArray+=( "''" )
		else
			resultArray+=( "$value" )
		fi
	done
	local rawResult=$(eval "${resultArray[*]}" 2> /dev/null)
	local result=$(grep -v '^:[0-9]*$' <<< "$rawResult")

	# Compose V2 completions sometimes returns returns `:8` (ShellCompDirectiveFilterFileExt)
	# with the expected file extensions (such as `yml`, `yaml`) to indicate that the shell should
	# provide autocompletions for files with matching extensions
	local completionFlag=$(tail -1 <<< "$rawResult")
	if [ "$completionFlag" == ":8" ]; then
		# format a valid glob pattern for the provided file extensions
		local filePattern=$(tr '\n' '|' <<< "$result")

		_filedir "$filePattern"
		return
	fi

	# if result empty, just use filename completion as fallback
	if [ -z "$result" ]; then
		_filedir
	else
		COMPREPLY=( $(compgen -W "${result}" -- "${current-}") )
	fi
}

_docker_docker() {
	# global options that may appear after the docker command
	local boolean_options="
		$global_boolean_options
		--help
		--version -v
	"

	case "$prev" in
		--config)
			_filedir -d
			return
			;;
		--context|-c)
			__docker_complete_contexts
			return
			;;
		--log-level|-l)
			__docker_complete_log_levels
			return
			;;
		$(__docker_to_extglob "$global_options_with_args") )
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "$boolean_options $global_options_with_args" -- "$cur" ) )
			;;
		*)
			local counter=$( __docker_pos_first_nonflag "$(__docker_to_extglob "$global_options_with_args")" )
			if [ "$cword" -eq "$counter" ]; then
				__docker_server_is_experimental && commands+=(${experimental_server_commands[*]})
				COMPREPLY=( $( compgen -W "${commands[*]} help" -- "$cur" ) )
			fi
			;;
	esac
}

_docker_attach() {
	_docker_container_attach
}

_docker_build() {
	_docker_image_build
}


_docker_builder() {
	local subcommands="
		build
		prune
	"
	__docker_subcommands "$subcommands" && return

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
			;;
	esac
}

_docker_builder_build() {
	_docker_image_build
}

_docker_builder_prune() {
	case "$prev" in
		--filter)
			COMPREPLY=( $( compgen -S = -W "description id inuse parent private shared type until unused-for" -- "$cur" ) )
			__docker_nospace
			return
			;;
		--keep-storage)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--all -a --filter --force -f --help --keep-storage" -- "$cur" ) )
			;;
	esac
}

_docker_checkpoint() {
	local subcommands="
		create
		ls
		rm
	"
	local aliases="
		list
		remove
	"
	__docker_subcommands "$subcommands $aliases" && return

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
			;;
	esac
}

_docker_checkpoint_create() {
	case "$prev" in
		--checkpoint-dir)
			_filedir -d
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--checkpoint-dir --help --leave-running" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag '--checkpoint-dir')
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_containers_running
			fi
			;;
	esac
}

_docker_checkpoint_ls() {
	case "$prev" in
		--checkpoint-dir)
			_filedir -d
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--checkpoint-dir --help" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag '--checkpoint-dir')
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_containers_all
			fi
			;;
	esac
}

_docker_checkpoint_rm() {
	case "$prev" in
		--checkpoint-dir)
			_filedir -d
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--checkpoint-dir --help" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag '--checkpoint-dir')
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_containers_all
			elif [ "$cword" -eq "$((counter + 1))" ]; then
				COMPREPLY=( $( compgen -W "$(__docker_q checkpoint ls "$prev" | sed 1d)" -- "$cur" ) )
			fi
			;;
	esac
}


_docker_config() {
	local subcommands="
		create
		inspect
		ls
		rm
	"
	local aliases="
		list
		remove
	"
	__docker_subcommands "$subcommands $aliases" && return

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
			;;
	esac
}

_docker_config_create() {
	case "$prev" in
		--label|-l)
			return
			;;
		--template-driver)
			COMPREPLY=( $( compgen -W "golang" -- "$cur" ) )
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help --label -l --template-driver" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag '--label|-l|--template-driver')
			if [ "$cword" -eq "$((counter + 1))" ]; then
				_filedir
			fi
			;;
	esac
}

_docker_config_inspect() {
	case "$prev" in
		--format|-f)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--format -f --help --pretty" -- "$cur" ) )
			;;
		*)
			__docker_complete_configs
			;;
	esac
}

_docker_config_list() {
	_docker_config_ls
}

_docker_config_ls() {
	local key=$(__docker_map_key_of_current_option '--filter|-f')
	case "$key" in
		id)
			__docker_complete_configs --cur "${cur##*=}" --id
			return
			;;
		name)
			__docker_complete_configs --cur "${cur##*=}" --name
			return
			;;
	esac

	case "$prev" in
		--filter|-f)
			COMPREPLY=( $( compgen -S = -W "id label name" -- "$cur" ) )
			__docker_nospace
			return
			;;
		--format)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--format --filter -f --help --quiet -q" -- "$cur" ) )
			;;
	esac
}

_docker_config_remove() {
	_docker_config_rm
}

_docker_config_rm() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			__docker_complete_configs
			;;
	esac
}


_docker_container() {
	local subcommands="
		attach
		commit
		cp
		create
		diff
		exec
		export
		inspect
		kill
		logs
		ls
		pause
		port
		prune
		rename
		restart
		rm
		run
		start
		stats
		stop
		top
		unpause
		update
		wait
	"
	local aliases="
		list
		ps
	"
	__docker_subcommands "$subcommands $aliases" && return

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
			;;
	esac
}

_docker_container_attach() {
	__docker_complete_detach_keys && return

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--detach-keys --help --no-stdin --sig-proxy=false" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag '--detach-keys')
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_containers_running
			fi
			;;
	esac
}

_docker_container_commit() {
	case "$prev" in
		--author|-a|--change|-c|--message|-m)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--author -a --change -c --help --message -m --pause=false -p=false" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag '--author|-a|--change|-c|--message|-m')

			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_containers_all
				return
			elif [ "$cword" -eq "$((counter + 1))" ]; then
				__docker_complete_images --repo --tag
				return
			fi
			;;
	esac
}

_docker_container_cp() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--archive -a --follow-link -L --help" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag)
			if [ "$cword" -eq "$counter" ]; then
				case "$cur" in
					*:)
						return
						;;
					*)
						# combined container and filename completion
						_filedir
						local files=( ${COMPREPLY[@]} )

						__docker_complete_containers_all
						COMPREPLY=( $( compgen -W "${COMPREPLY[*]}" -S ':' ) )
						local containers=( ${COMPREPLY[@]} )

						COMPREPLY=( $( compgen -W "${files[*]} ${containers[*]}" -- "$cur" ) )
						if [[ "${COMPREPLY[*]}" = *: ]]; then
							__docker_nospace
						fi
						return
						;;
				esac
			fi
			(( counter++ ))

			if [ "$cword" -eq "$counter" ]; then
				if [ -e "$prev" ]; then
					__docker_complete_containers_all
					COMPREPLY=( $( compgen -W "${COMPREPLY[*]}" -S ':' ) )
					__docker_nospace
				else
					_filedir
				fi
				return
			fi
			;;
	esac
}

_docker_container_create() {
	_docker_container_run_and_create
}

_docker_container_diff() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag)
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_containers_all
			fi
			;;
	esac
}

_docker_container_exec() {
	__docker_complete_detach_keys && return

	case "$prev" in
		--env|-e)
			# we do not append a "=" here because "-e VARNAME" is legal syntax, too
			COMPREPLY=( $( compgen -e -- "$cur" ) )
			__docker_nospace
			return
			;;
		--env-file)
			_filedir
			return
			;;
		--user|-u)
			__docker_complete_user_group
			return
			;;
		--workdir|-w)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--detach -d --detach-keys --env -e --env-file --help --interactive -i --privileged -t --tty -u --user --workdir -w" -- "$cur" ) )
			;;
		*)
			__docker_complete_containers_running
			;;
	esac
}

_docker_container_export() {
	case "$prev" in
		--output|-o)
			_filedir
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help --output -o" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag)
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_containers_all
			fi
			;;
	esac
}

_docker_container_inspect() {
	_docker_inspect --type container
}

_docker_container_kill() {
	case "$prev" in
		--signal|-s)
			__docker_complete_signals
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help --signal -s" -- "$cur" ) )
			;;
		*)
			__docker_complete_containers_running
			;;
	esac
}

_docker_container_logs() {
	case "$prev" in
		--since|--tail|-n|--until)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--details --follow -f --help --since --tail -n --timestamps -t --until" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag '--since|--tail|-n|--until')
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_containers_all
			fi
			;;
	esac
}

_docker_container_list() {
	_docker_container_ls
}

_docker_container_ls() {
	local key=$(__docker_map_key_of_current_option '--filter|-f')
	case "$key" in
		ancestor)
			__docker_complete_images --cur "${cur##*=}" --repo --tag --id
			return
			;;
		before)
			__docker_complete_containers_all --cur "${cur##*=}"
			return
			;;
		expose|publish)
			return
			;;
		id)
			__docker_complete_containers_all --cur "${cur##*=}" --id
			return
			;;
		health)
			COMPREPLY=( $( compgen -W "healthy starting none unhealthy" -- "${cur##*=}" ) )
			return
			;;
		is-task)
			COMPREPLY=( $( compgen -W "true false" -- "${cur##*=}" ) )
			return
			;;
		name)
			__docker_complete_containers_all --cur "${cur##*=}" --name
			return
			;;
		network)
			__docker_complete_networks --cur "${cur##*=}"
			return
			;;
		since)
			__docker_complete_containers_all --cur "${cur##*=}"
			return
			;;
		status)
			COMPREPLY=( $( compgen -W "created dead exited paused restarting running removing" -- "${cur##*=}" ) )
			return
			;;
		volume)
			__docker_complete_volumes --cur "${cur##*=}"
			return
			;;
	esac

	case "$prev" in
		--filter|-f)
			COMPREPLY=( $( compgen -S = -W "ancestor before exited expose health id is-task label name network publish since status volume" -- "$cur" ) )
			__docker_nospace
			return
			;;
		--format|--last|-n)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--all -a --filter -f --format --help --last -n --latest -l --no-trunc --quiet -q --size -s" -- "$cur" ) )
			;;
	esac
}

_docker_container_pause() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			__docker_complete_containers_running
			;;
	esac
}

_docker_container_port() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag)
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_containers_all
			fi
			;;
	esac
}

_docker_container_prune() {
	case "$prev" in
		--filter)
			COMPREPLY=( $( compgen -W "label label! until" -S = -- "$cur" ) )
			__docker_nospace
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--force -f --filter --help" -- "$cur" ) )
			;;
	esac
}

_docker_container_ps() {
	_docker_container_ls
}

_docker_container_rename() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag)
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_containers_all
			fi
			;;
	esac
}

_docker_container_restart() {
	case "$prev" in
		--timeout|--time|-t)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help --timeout -t" -- "$cur" ) )
			;;
		*)
			__docker_complete_containers_all
			;;
	esac
}

_docker_container_rm() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--force -f --help --link -l --volumes -v" -- "$cur" ) )
			;;
		*)
			for arg in "${COMP_WORDS[@]}"; do
				case "$arg" in
					--force|-f)
						__docker_complete_containers_all
						return
						;;
				esac
			done
			__docker_complete_containers_removable
			;;
	esac
}

_docker_container_run() {
	_docker_container_run_and_create
}

# _docker_container_run_and_create is the combined completion for `_docker_container_run`
# and `_docker_container_create`
_docker_container_run_and_create() {
	local options_with_args="
		--add-host
		--annotation
		--attach -a
		--blkio-weight
		--blkio-weight-device
		--cap-add
		--cap-drop
		--cgroupns
		--cgroup-parent
		--cidfile
		--cpu-period
		--cpu-quota
		--cpu-rt-period
		--cpu-rt-runtime
		--cpuset-cpus
		--cpus
		--cpuset-mems
		--cpu-shares -c
		--device
		--device-cgroup-rule
		--device-read-bps
		--device-read-iops
		--device-write-bps
		--device-write-iops
		--dns
		--dns-option
		--dns-search
		--domainname
		--entrypoint
		--env -e
		--env-file
		--expose
		--gpus
		--group-add
		--health-cmd
		--health-interval
		--health-retries
		--health-start-period
		--health-timeout
		--hostname -h
		--ip
		--ip6
		--ipc
		--kernel-memory
		--label-file
		--label -l
		--link
		--link-local-ip
		--log-driver
		--log-opt
		--mac-address
		--memory -m
		--memory-swap
		--memory-swappiness
		--memory-reservation
		--mount
		--name
		--network
		--network-alias
		--oom-score-adj
		--pid
		--pids-limit
		--platform
		--publish -p
		--pull
		--restart
		--runtime
		--security-opt
		--shm-size
		--stop-signal
		--stop-timeout
		--storage-opt
		--tmpfs
		--sysctl
		--ulimit
		--user -u
		--userns
		--uts
		--volume-driver
		--volumes-from
		--volume -v
		--workdir -w
	"
	__docker_server_os_is windows && options_with_args+="
		--cpu-count
		--cpu-percent
		--io-maxbandwidth
		--io-maxiops
		--isolation
	"

	local boolean_options="
		--disable-content-trust=false
		--help
		--init
		--interactive -i
		--no-healthcheck
		--oom-kill-disable
		--privileged
		--publish-all -P
		--quiet -q
		--read-only
		--tty -t
	"

	if [ "$command" = "run" ] || [ "$subcommand" = "run" ] ; then
		options_with_args="$options_with_args
			--detach-keys
		"
		boolean_options="$boolean_options
			--detach -d
			--rm
			--sig-proxy=false
		"
		__docker_complete_detach_keys && return
	fi

	local all_options="$options_with_args $boolean_options"


	__docker_complete_log_driver_options && return
	__docker_complete_restart && return

	local key=$(__docker_map_key_of_current_option '--security-opt')
	case "$key" in
		label)
			[[ $cur == *: ]] && return
			COMPREPLY=( $( compgen -W "user: role: type: level: disable" -- "${cur##*=}") )
			if [ "${COMPREPLY[*]}" != "disable" ] ; then
				__docker_nospace
			fi
			return
			;;
		seccomp)
			local cur=${cur##*=}
			_filedir
			COMPREPLY+=( $( compgen -W "unconfined" -- "$cur" ) )
			return
			;;
	esac

	case "$prev" in
		--add-host)
			case "$cur" in
				*:)
					__docker_complete_resolved_hostname
					return
					;;
			esac
			;;
		--attach|-a)
			COMPREPLY=( $( compgen -W 'stdin stdout stderr' -- "$cur" ) )
			return
			;;
		--cap-add)
			__docker_complete_capabilities_addable
			return
			;;
		--cap-drop)
			__docker_complete_capabilities_droppable
			return
			;;
		--cidfile|--env-file|--label-file)
			_filedir
			return
			;;
		--cgroupns)
			COMPREPLY=( $( compgen -W "host private" -- "$cur" ) )
			return
			;;
		--device|--tmpfs|--volume|-v)
			case "$cur" in
				*:*)
					# TODO somehow do _filedir for stuff inside the image, if it's already specified (which is also somewhat difficult to determine)
					;;
				'')
					COMPREPLY=( $( compgen -W '/' -- "$cur" ) )
					__docker_nospace
					;;
				/*)
					_filedir
					__docker_nospace
					;;
			esac
			return
			;;
		--env|-e)
			# we do not append a "=" here because "-e VARNAME" is legal syntax, too
			COMPREPLY=( $( compgen -e -- "$cur" ) )
			__docker_nospace
			return
			;;
		--ipc)
			case "$cur" in
				*:*)
					cur="${cur#*:}"
					__docker_complete_containers_running
					;;
				*)
					COMPREPLY=( $( compgen -W 'none host private shareable container:' -- "$cur" ) )
					if [ "${COMPREPLY[*]}" = "container:" ]; then
						__docker_nospace
					fi
					;;
			esac
			return
			;;
		--isolation)
			if __docker_server_os_is windows ; then
				__docker_complete_isolation
				return
			fi
			;;
		--link)
			case "$cur" in
				*:*)
					;;
				*)
					__docker_complete_containers_running
					COMPREPLY=( $( compgen -W "${COMPREPLY[*]}" -S ':' ) )
					__docker_nospace
					;;
			esac
			return
			;;
		--log-driver)
			__docker_complete_log_drivers
			return
			;;
		--log-opt)
			__docker_complete_log_options
			return
			;;
		--network)
			case "$cur" in
				container:*)
					__docker_complete_containers_all --cur "${cur#*:}"
					;;
				*)
					COMPREPLY=( $( compgen -W "$(__docker_plugins_bundled --type Network) $(__docker_networks) container:" -- "$cur") )
					if [ "${COMPREPLY[*]}" = "container:" ] ; then
						__docker_nospace
					fi
					;;
			esac
			return
			;;
		--pid)
			case "$cur" in
				*:*)
					__docker_complete_containers_running --cur "${cur#*:}"
					;;
				*)
					COMPREPLY=( $( compgen -W 'host container:' -- "$cur" ) )
					if [ "${COMPREPLY[*]}" = "container:" ]; then
						__docker_nospace
					fi
					;;
			esac
			return
			;;
		--pull)
		  COMPREPLY=( $( compgen -W 'always missing never' -- "$cur" ) )
		  return
		  ;;
		--runtime)
			__docker_complete_runtimes
			return
			;;
		--security-opt)
			COMPREPLY=( $( compgen -W "apparmor= label= no-new-privileges seccomp= systempaths=unconfined" -- "$cur") )
			if [[ ${COMPREPLY[*]} = *= ]] ; then
				__docker_nospace
			fi
			return
			;;
		--stop-signal)
			__docker_complete_signals
			return
			;;
		--storage-opt)
			COMPREPLY=( $( compgen -W "size" -S = -- "$cur") )
			__docker_nospace
			return
			;;
		--ulimit)
			__docker_complete_ulimits
			return
			;;
		--user|-u)
			__docker_complete_user_group
			return
			;;
		--userns)
			COMPREPLY=( $( compgen -W "host" -- "$cur" ) )
			return
			;;
		--volume-driver)
			__docker_complete_plugins_bundled --type Volume
			return
			;;
		--volumes-from)
			__docker_complete_containers_all
			return
			;;
		$(__docker_to_extglob "$options_with_args") )
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
			;;
		*)
			local counter=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" )
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_images --repo --tag --id
			fi
			;;
	esac
}

_docker_container_start() {
	__docker_complete_detach_keys && return
	case "$prev" in
		--checkpoint)
			if __docker_server_is_experimental ; then
				return
			fi
			;;
		--checkpoint-dir)
			if __docker_server_is_experimental ; then
				_filedir -d
				return
			fi
			;;
	esac

	case "$cur" in
		-*)
			local options="--attach -a --detach-keys --help --interactive -i"
			__docker_server_is_experimental && options+=" --checkpoint --checkpoint-dir"
			COMPREPLY=( $( compgen -W "$options" -- "$cur" ) )
			;;
		*)
			__docker_complete_containers_stopped
			;;
	esac
}

_docker_container_stats() {
	case "$prev" in
		--format)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--all -a --format --help --no-stream --no-trunc" -- "$cur" ) )
			;;
		*)
			__docker_complete_containers_running
			;;
	esac
}

_docker_container_stop() {
	case "$prev" in
		--timeout|--time|-t)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help --timeout -t" -- "$cur" ) )
			;;
		*)
			__docker_complete_containers_stoppable
			;;
	esac
}

_docker_container_top() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag)
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_containers_running
			fi
			;;
	esac
}

_docker_container_unpause() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag)
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_containers_unpauseable
			fi
			;;
	esac
}

_docker_container_update() {
	local options_with_args="
		--blkio-weight
		--cpu-period
		--cpu-quota
		--cpu-rt-period
		--cpu-rt-runtime
		--cpus
		--cpuset-cpus
		--cpuset-mems
		--cpu-shares -c
		--kernel-memory
		--memory -m
		--memory-reservation
		--memory-swap
		--pids-limit
		--restart
	"

	local boolean_options="
		--help
	"

	local all_options="$options_with_args $boolean_options"

	__docker_complete_restart && return

	case "$prev" in
		$(__docker_to_extglob "$options_with_args") )
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
			;;
		*)
			__docker_complete_containers_all
			;;
	esac
}

_docker_container_wait() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			__docker_complete_containers_all
			;;
	esac
}


_docker_context() {
	local subcommands="
		create
		export
		import
		inspect
		ls
		rm
		update
		use
	"
	local aliases="
		list
		remove
	"
	__docker_subcommands "$subcommands $aliases" && return

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
			;;
	esac
}

_docker_context_create() {
	case "$prev" in
		--description|--docker)
			return
			;;
		--from)
			__docker_complete_contexts
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--description --docker --from --help" -- "$cur" ) )
			;;
	esac
}

_docker_context_export() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag)
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_contexts
			elif [ "$cword" -eq "$((counter + 1))" ]; then
				_filedir
			fi
			;;
	esac
}

_docker_context_import() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag)
			if [ "$cword" -eq "$counter" ]; then
				:
			elif [ "$cword" -eq "$((counter + 1))" ]; then
				_filedir
			fi
			;;
	esac
}

_docker_context_inspect() {
	case "$prev" in
		--format|-f)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--format -f --help" -- "$cur" ) )
			;;
		*)
			__docker_complete_contexts
			;;
	esac
}

_docker_context_list() {
	_docker_context_ls
}

_docker_context_ls() {
	case "$prev" in
		--format|-f)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--format -f --help --quiet -q" -- "$cur" ) )
			;;
	esac
}

_docker_context_remove() {
	_docker_context_rm
}

_docker_context_rm() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--force -f --help" -- "$cur" ) )
			;;
		*)
			__docker_complete_contexts
			;;
	esac
}

_docker_context_update() {
	case "$prev" in
		--description|--docker)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--description --docker --help" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag)
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_contexts
			fi
			;;
	esac
}

_docker_context_use() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag)
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_contexts --add default
			fi
			;;
	esac
}


_docker_commit() {
	_docker_container_commit
}

_docker_cp() {
	_docker_container_cp
}

_docker_create() {
	_docker_container_create
}

_docker_daemon() {
	local boolean_options="
		$global_boolean_options
		--experimental
		--help
		--icc=false
		--init
		--ip-forward=false
		--ip-masq=false
		--iptables=false
		--ip6tables
		--ipv6
		--live-restore
		--no-new-privileges
		--raw-logs
		--selinux-enabled
		--userland-proxy=false
		--validate
		--version -v
	"
	local options_with_args="
		$global_options_with_args
		--add-runtime
		--allow-nondistributable-artifacts
		--api-cors-header
		--authorization-plugin
		--bip
		--bridge -b
		--cgroup-parent
		--config-file
		--containerd
		--containerd-namespace
		--containerd-plugins-namespace
		--cpu-rt-period
		--cpu-rt-runtime
		--data-root
		--default-address-pool
		--default-gateway
		--default-gateway-v6
		--default-runtime
		--default-shm-size
		--default-ulimit
		--dns
		--dns-search
		--dns-opt
		--exec-opt
		--exec-root
		--fixed-cidr
		--fixed-cidr-v6
		--group -G
		--init-path
		--insecure-registry
		--ip
		--label
		--log-driver
		--log-opt
		--max-concurrent-downloads
		--max-concurrent-uploads
		--max-download-attempts
		--metrics-addr
		--mtu
		--network-control-plane-mtu
		--node-generic-resource
		--oom-score-adjust
		--pidfile -p
		--registry-mirror
		--seccomp-profile
		--shutdown-timeout
		--storage-driver -s
		--storage-opt
		--swarm-default-advertise-addr
		--userland-proxy-path
		--userns-remap
	"

	__docker_complete_log_driver_options && return

 	local key=$(__docker_map_key_of_current_option '--storage-opt')
 	case "$key" in
 		dm.blkdiscard|dm.override_udev_sync_check|dm.use_deferred_removal|dm.use_deferred_deletion)
 			COMPREPLY=( $( compgen -W "false true" -- "${cur##*=}" ) )
 			return
 			;;
		dm.directlvm_device|dm.thinpooldev)
			cur=${cur##*=}
			_filedir
			return
			;;
		dm.fs)
			COMPREPLY=( $( compgen -W "ext4 xfs" -- "${cur##*=}" ) )
			return
			;;
		dm.libdm_log_level)
			COMPREPLY=( $( compgen -W "2 3 4 5 6 7" -- "${cur##*=}" ) )
			return
			;;
 	esac

	case "$prev" in
		--authorization-plugin)
			__docker_complete_plugins_bundled --type Authorization
			return
			;;
		--config-file|--containerd|--init-path|--pidfile|-p|--tlscacert|--tlscert|--tlskey|--userland-proxy-path)
			_filedir
			return
			;;
		--default-ulimit)
			__docker_complete_ulimits
			return
			;;
		--exec-root|--data-root)
			_filedir -d
			return
			;;
		--log-driver)
			__docker_complete_log_drivers
			return
			;;
		--storage-driver|-s)
			COMPREPLY=( $( compgen -W "btrfs overlay2 vfs zfs" -- "$(echo "$cur" | tr '[:upper:]' '[:lower:]')" ) )
			return
			;;
		--storage-opt)
			local btrfs_options="btrfs.min_space"
			local overlay2_options="overlay2.size"
			local zfs_options="zfs.fsname"

			local all_options="$btrfs_options $overlay2_options $zfs_options"

			case $(__docker_value_of_option '--storage-driver|-s') in
				'')
					COMPREPLY=( $( compgen -W "$all_options" -S = -- "$cur" ) )
					;;
				btrfs)
					COMPREPLY=( $( compgen -W "$btrfs_options" -S = -- "$cur" ) )
					;;
				overlay2)
					COMPREPLY=( $( compgen -W "$overlay2_options" -S = -- "$cur" ) )
					;;
				zfs)
					COMPREPLY=( $( compgen -W "$zfs_options" -S = -- "$cur" ) )
					;;
				*)
					return
					;;
			esac
			__docker_nospace
			return
			;;
		--log-level|-l)
			__docker_complete_log_levels
			return
			;;
		--log-opt)
			__docker_complete_log_options
			return
			;;
		--metrics-addr)
			__docker_complete_local_ips
			__docker_append_to_completions ":"
			__docker_nospace
			return
			;;
		--seccomp-profile)
			_filedir json
			return
			;;
		--swarm-default-advertise-addr)
			__docker_complete_local_interfaces
			return
			;;
		--userns-remap)
			__docker_complete_user_group
			return
			;;
		$(__docker_to_extglob "$options_with_args") )
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "$boolean_options $options_with_args" -- "$cur" ) )
			;;
	esac
}

_docker_diff() {
	_docker_container_diff
}


_docker_events() {
	_docker_system_events
}

_docker_exec() {
	_docker_container_exec
}

_docker_export() {
	_docker_container_export
}

_docker_help() {
	local counter=$(__docker_pos_first_nonflag)
	if [ "$cword" -eq "$counter" ]; then
		COMPREPLY=( $( compgen -W "${commands[*]}" -- "$cur" ) )
	fi
}

_docker_history() {
	_docker_image_history
}


_docker_image() {
	local subcommands="
		build
		history
		import
		inspect
		load
		ls
		prune
		pull
		push
		rm
		save
		tag
	"
	local aliases="
		images
		list
		remove
		rmi
	"
	__docker_subcommands "$subcommands $aliases" && return

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
			;;
	esac
}

_docker_image_build() {
	local options_with_args="
		--add-host
		--build-arg
		--cache-from
		--cgroup-parent
		--cpuset-cpus
		--cpuset-mems
		--cpu-shares -c
		--cpu-period
		--cpu-quota
		--file -f
		--iidfile
		--label
		--memory -m
		--memory-swap
		--network
		--platform
		--shm-size
		--tag -t
		--target
		--ulimit
	"
	__docker_server_os_is windows && options_with_args+="
		--isolation
	"

	local boolean_options="
		--disable-content-trust=false
		--force-rm
		--help
		--no-cache
		--pull
		--quiet -q
		--rm
	"

	if __docker_server_is_experimental ; then
		boolean_options+="
			--squash
		"
	fi

	if [ "${DOCKER_BUILDKIT-}" = "1" ] ; then
		options_with_args+="
			--output -o
			--progress
			--secret
			--ssh
		"
	else
		boolean_options+="
			--compress
		"
	fi

	local all_options="$options_with_args $boolean_options"

	case "$prev" in
		--add-host)
			case "$cur" in
				*:)
					__docker_complete_resolved_hostname
					return
					;;
			esac
			;;
		--build-arg)
			COMPREPLY=( $( compgen -e -- "$cur" ) )
			__docker_nospace
			return
			;;
		--cache-from)
			__docker_complete_images --repo --tag --id
			return
			;;
		--file|-f|--iidfile)
			_filedir
			return
			;;
		--isolation)
			if __docker_server_os_is windows ; then
				__docker_complete_isolation
				return
			fi
			;;
		--network)
			case "$cur" in
				container:*)
					__docker_complete_containers_all --cur "${cur#*:}"
					;;
				*)
					COMPREPLY=( $( compgen -W "$(__docker_plugins_bundled --type Network) $(__docker_networks) container:" -- "$cur") )
					if [ "${COMPREPLY[*]}" = "container:" ] ; then
						__docker_nospace
					fi
					;;
			esac
			return
			;;
		--progress)
			COMPREPLY=( $( compgen -W "auto plain tty" -- "$cur" ) )
			return
			;;
		--tag|-t)
			__docker_complete_images --repo --tag
			return
			;;
		--target)
			local context_pos=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" )
			local context="${words[$context_pos]}"
			context="${context:-.}"

			local file="$( __docker_value_of_option '--file|f' )"
			local default_file="${context%/}/Dockerfile"
			local dockerfile="${file:-$default_file}"

			local targets="$( sed -n 's/^FROM .\+ AS \(.\+\)/\1/p' "$dockerfile" 2>/dev/null )"
			COMPREPLY=( $( compgen -W "$targets" -- "$cur" ) )
			return
			;;
		--ulimit)
			__docker_complete_ulimits
			return
			;;
		$(__docker_to_extglob "$options_with_args") )
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
			;;
		*)
			local counter=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" )
			if [ "$cword" -eq "$counter" ]; then
				_filedir -d
			fi
			;;
	esac
}

_docker_image_history() {
	case "$prev" in
		--format)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--format --help --human=false -H=false --no-trunc --quiet -q" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag '--format')
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_images --force-tag --id
			fi
			;;
	esac
}

_docker_image_images() {
	_docker_image_ls
}

_docker_image_import() {
	case "$prev" in
		--change|-c|--message|-m|--platform)
			return
			;;
	esac

	case "$cur" in
		-*)
			local options="--change -c --help --message -m --platform"
			COMPREPLY=( $( compgen -W "$options" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag '--change|-c|--message|-m')
			if [ "$cword" -eq "$counter" ]; then
				_filedir
				return
			elif [ "$cword" -eq "$((counter + 1))" ]; then
				__docker_complete_images --repo --tag
				return
			fi
			;;
	esac
}

_docker_image_inspect() {
	_docker_inspect --type image
}

_docker_image_load() {
	case "$prev" in
		--input|-i|"<")
			_filedir
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help --input -i --quiet -q" -- "$cur" ) )
			;;
	esac
}

_docker_image_list() {
	_docker_image_ls
}

_docker_image_ls() {
	local key=$(__docker_map_key_of_current_option '--filter|-f')
	case "$key" in
		before|since)
			__docker_complete_images --cur "${cur##*=}" --force-tag --id
			return
			;;
		dangling)
			COMPREPLY=( $( compgen -W "false true" -- "${cur##*=}" ) )
			return
			;;
		label)
			return
			;;
		reference)
			__docker_complete_images --cur "${cur##*=}" --repo --tag
			return
			;;
	esac

	case "$prev" in
		--filter|-f)
			COMPREPLY=( $( compgen -S = -W "before dangling label reference since" -- "$cur" ) )
			__docker_nospace
			return
			;;
                --format)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--all -a --digests --filter -f --format --help --no-trunc --quiet -q" -- "$cur" ) )
			;;
		=)
			return
			;;
		*)
			__docker_complete_images --repo --tag
			;;
	esac
}

_docker_image_prune() {
	case "$prev" in
		--filter)
			COMPREPLY=( $( compgen -W "label label! until" -S = -- "$cur" ) )
			__docker_nospace
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--all -a --force -f --filter --help" -- "$cur" ) )
			;;
	esac
}

_docker_image_pull() {
	case "$prev" in
		--platform)
			return
			;;
	esac

	case "$cur" in
		-*)
			local options="--all-tags -a --disable-content-trust=false --help --platform --quiet -q"
			COMPREPLY=( $( compgen -W "$options" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag --platform)
			if [ "$cword" -eq "$counter" ]; then
				for arg in "${COMP_WORDS[@]}"; do
					case "$arg" in
						--all-tags|-a)
							__docker_complete_images --repo
							return
							;;
					esac
				done
				__docker_complete_images --repo --tag
			fi
			;;
	esac
}

_docker_image_push() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--all-tags -a --disable-content-trust=false --help --quiet -q" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag)
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_images --repo --tag
			fi
			;;
	esac
}

_docker_image_remove() {
	_docker_image_rm
}

_docker_image_rm() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--force -f --help --no-prune" -- "$cur" ) )
			;;
		*)
			__docker_complete_images --force-tag --id
			;;
	esac
}

_docker_image_rmi() {
	_docker_image_rm
}

_docker_image_save() {
	case "$prev" in
		--output|-o|">")
			_filedir
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help --output -o" -- "$cur" ) )
			;;
		*)
			__docker_complete_images --repo --tag --id
			;;
	esac
}

_docker_image_tag() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag)

			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_images --force-tag --id
				return
			elif [ "$cword" -eq "$((counter + 1))" ]; then
				__docker_complete_images --repo --tag
				return
			fi
			;;
	esac
}


_docker_images() {
	_docker_image_ls
}

_docker_import() {
	_docker_image_import
}

_docker_info() {
	_docker_system_info
}

_docker_inspect() {
	local preselected_type
	local type

	if [ "${1-}" = "--type" ] ; then
		preselected_type=yes
		type="$2"
	else
		type=$(__docker_value_of_option --type)
	fi

	case "$prev" in
		--format|-f)
			return
			;;
		--type)
			if [ -z "$preselected_type" ] ; then
				COMPREPLY=( $( compgen -W "container image network node plugin secret service volume" -- "$cur" ) )
				return
			fi
			;;
	esac

	case "$cur" in
		-*)
			local options="--format -f --help --size -s"
			if [ -z "$preselected_type" ] ; then
				options+=" --type"
			fi
			COMPREPLY=( $( compgen -W "$options" -- "$cur" ) )
			;;
		*)
			case "$type" in
				'')
					COMPREPLY=( $( compgen -W "
						$(__docker_containers --all)
						$(__docker_images --force-tag --id)
						$(__docker_networks)
						$(__docker_nodes)
						$(__docker_plugins_installed)
						$(__docker_secrets)
						$(__docker_services)
						$(__docker_volumes)
					" -- "$cur" ) )
					__ltrim_colon_completions "$cur"
					;;
				container)
					__docker_complete_containers_all
					;;
				image)
					__docker_complete_images --force-tag --id
					;;
				network)
					__docker_complete_networks
					;;
				node)
					__docker_complete_nodes
					;;
				plugin)
					__docker_complete_plugins_installed
					;;
				secret)
					__docker_complete_secrets
					;;
				service)
					__docker_complete_services
					;;
				volume)
					__docker_complete_volumes
					;;
			esac
	esac
}

_docker_kill() {
	_docker_container_kill
}

_docker_load() {
	_docker_image_load
}

_docker_login() {
	case "$prev" in
		--password|-p|--username|-u)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help --password -p --password-stdin --username -u" -- "$cur" ) )
			;;
	esac
}

_docker_logout() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
	esac
}

_docker_logs() {
	_docker_container_logs
}

_docker_network_connect() {
	local options_with_args="
		--alias
		--ip
		--ip6
		--link
		--link-local-ip
	"

	local boolean_options="
		--help
	"

	case "$prev" in
		--link)
			case "$cur" in
				*:*)
					;;
				*)
					__docker_complete_containers_running
					COMPREPLY=( $( compgen -W "${COMPREPLY[*]}" -S ':' ) )
					__docker_nospace
					;;
			esac
			return
			;;
		$(__docker_to_extglob "$options_with_args") )
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "$boolean_options $options_with_args" -- "$cur" ) )
			;;
		*)
			local counter=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" )
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_networks
			elif [ "$cword" -eq "$((counter + 1))" ]; then
				__docker_complete_containers_all
			fi
			;;
	esac
}

_docker_network_create() {
	case "$prev" in
		--aux-address|--gateway|--ip-range|--ipam-opt|--ipv6|--opt|-o|--subnet)
			return
			;;
		--config-from)
			__docker_complete_networks
			return
			;;
		--driver|-d)
			# remove drivers that allow one instance only, add drivers missing in `docker info`
			__docker_complete_plugins_bundled --type Network --remove host --remove null --add macvlan
			return
			;;
		--ipam-driver)
			COMPREPLY=( $( compgen -W "default" -- "$cur" ) )
			return
			;;
		--label)
			return
			;;
		--scope)
			COMPREPLY=( $( compgen -W "local swarm" -- "$cur" ) )
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--attachable --aux-address --config-from --config-only --driver -d --gateway --help --ingress --internal --ip-range --ipam-driver --ipam-opt --ipv6 --label --opt -o --scope --subnet" -- "$cur" ) )
			;;
	esac
}

_docker_network_disconnect() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag)
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_networks
			elif [ "$cword" -eq "$((counter + 1))" ]; then
				__docker_complete_containers_in_network "$prev"
			fi
			;;
	esac
}

_docker_network_inspect() {
	case "$prev" in
		--format|-f)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--format -f --help --verbose" -- "$cur" ) )
			;;
		*)
			__docker_complete_networks
	esac
}

_docker_network_ls() {
	local key=$(__docker_map_key_of_current_option '--filter|-f')
	case "$key" in
		dangling)
			COMPREPLY=( $( compgen -W "false true" -- "${cur##*=}" ) )
			return
			;;
		driver)
			__docker_complete_plugins_bundled --cur "${cur##*=}" --type Network --add macvlan
			return
			;;
		id)
			__docker_complete_networks --cur "${cur##*=}" --id
			return
			;;
		name)
			__docker_complete_networks --cur "${cur##*=}" --name
			return
			;;
		scope)
			COMPREPLY=( $( compgen -W "global local swarm" -- "${cur##*=}" ) )
			return
			;;
		type)
			COMPREPLY=( $( compgen -W "builtin custom" -- "${cur##*=}" ) )
			return
			;;
	esac

	case "$prev" in
		--filter|-f)
			COMPREPLY=( $( compgen -S = -W "dangling driver id label name scope type" -- "$cur" ) )
			__docker_nospace
			return
			;;
		--format)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--filter -f --format --help --no-trunc --quiet -q" -- "$cur" ) )
			;;
	esac
}

_docker_network_prune() {
	case "$prev" in
		--filter)
			COMPREPLY=( $( compgen -W "label label! until" -S = -- "$cur" ) )
			__docker_nospace
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--force -f --filter --help" -- "$cur" ) )
			;;
	esac
}

_docker_network_rm() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--force -f --help" -- "$cur" ) )
			;;
		*)
			__docker_complete_networks --filter type=custom
	esac
}

_docker_network() {
	local subcommands="
		connect
		create
		disconnect
		inspect
		ls
		prune
		rm
	"
	local aliases="
		list
		remove
	"
	__docker_subcommands "$subcommands $aliases" && return

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
			;;
	esac
}

_docker_service() {
	local subcommands="
		create
		inspect
		logs
		ls
		rm
		rollback
		scale
		ps
		update
	"

	local aliases="
		list
		remove
	"
	__docker_subcommands "$subcommands $aliases" && return

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
			;;
	esac
}

_docker_service_create() {
	_docker_service_update_and_create
}

_docker_service_inspect() {
	case "$prev" in
		--format|-f)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--format -f --help --pretty" -- "$cur" ) )
			;;
		*)
			__docker_complete_services
	esac
}

_docker_service_logs() {
	case "$prev" in
		--since|--tail|-n)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--details --follow -f --help --no-resolve --no-task-ids --no-trunc --raw --since --tail -n --timestamps -t" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag '--since|--tail|-n')
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_services_and_tasks
			fi
			;;
	esac
}

_docker_service_list() {
	_docker_service_ls
}

_docker_service_ls() {
	local key=$(__docker_map_key_of_current_option '--filter|-f')
	case "$key" in
		id)
			__docker_complete_services --cur "${cur##*=}" --id
			return
			;;
		mode)
			COMPREPLY=( $( compgen -W "global global-job replicated replicated-job" -- "${cur##*=}" ) )
			return
			;;
		name)
			__docker_complete_services --cur "${cur##*=}" --name
			return
			;;
	esac

	case "$prev" in
		--filter|-f)
			COMPREPLY=( $( compgen -W "id label mode name" -S = -- "$cur" ) )
			__docker_nospace
			return
			;;
		--format)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--filter -f --format --help --quiet -q" -- "$cur" ) )
			;;
	esac
}

_docker_service_remove() {
	_docker_service_rm
}

_docker_service_rm() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			__docker_complete_services
	esac
}

_docker_service_rollback() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--detach -d --help --quit -q" -- "$cur" ) )
			;;
		*)
			local counter=$( __docker_pos_first_nonflag )
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_services
			fi
			;;
	esac
}

_docker_service_scale() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--detach -d --help" -- "$cur" ) )
			;;
		*)
			__docker_complete_services
			__docker_append_to_completions "="
			__docker_nospace
			;;
	esac
}

_docker_service_ps() {
	local key=$(__docker_map_key_of_current_option '--filter|-f')
	case "$key" in
		desired-state)
			COMPREPLY=( $( compgen -W "accepted running shutdown" -- "${cur##*=}" ) )
			return
			;;
		name)
			__docker_complete_services --cur "${cur##*=}" --name
			return
			;;
		node)
			__docker_complete_nodes --cur "${cur##*=}" --add self
			return
			;;
	esac

	case "$prev" in
		--filter|-f)
			COMPREPLY=( $( compgen -W "desired-state id name node" -S = -- "$cur" ) )
			__docker_nospace
			return
			;;
		--format)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--filter -f --format --help --no-resolve --no-trunc --quiet -q" -- "$cur" ) )
			;;
		*)
			__docker_complete_services
			;;
	esac
}

_docker_service_update() {
	_docker_service_update_and_create
}

# _docker_service_update_and_create is the combined completion for `docker service create`
# and `docker service update`
_docker_service_update_and_create() {
	local options_with_args="
		--cap-add
		--cap-drop
		--endpoint-mode
		--entrypoint
		--health-cmd
		--health-interval
		--health-retries
		--health-start-period
		--health-timeout
		--hostname
		--isolation
		--limit-cpu
		--limit-memory
		--limit-pids
		--log-driver
		--log-opt
		--max-replicas
		--replicas
		--replicas-max-per-node
		--reserve-cpu
		--reserve-memory
		--restart-condition
		--restart-delay
		--restart-max-attempts
		--restart-window
		--rollback-delay
		--rollback-failure-action
		--rollback-max-failure-ratio
		--rollback-monitor
		--rollback-order
		--rollback-parallelism
		--stop-grace-period
		--stop-signal
		--update-delay
		--update-failure-action
		--update-max-failure-ratio
		--update-monitor
		--update-order
		--update-parallelism
		--user -u
		--workdir -w
	"
	__docker_server_os_is windows && options_with_args+="
		--credential-spec
	"

	local boolean_options="
		--detach -d
		--help
		--init
		--no-healthcheck
		--no-resolve-image
		--read-only
		--tty -t
		--with-registry-auth
	"

	__docker_complete_log_driver_options && return

	if [ "$subcommand" = "create" ] ; then
		options_with_args="$options_with_args
			--config
			--constraint
			--container-label
			--dns
			--dns-option
			--dns-search
			--env -e
			--env-file
			--generic-resource
			--group
			--host
			--label -l
			--mode
			--mount
			--name
			--network
			--placement-pref
			--publish -p
			--secret
			--sysctl
			--ulimit
		"

		case "$prev" in
			--env-file)
				_filedir
				return
				;;
			--mode)
				COMPREPLY=( $( compgen -W "global global-job replicated replicated-job" -- "$cur" ) )
				return
				;;
		esac
	fi
	if [ "$subcommand" = "update" ] ; then
		options_with_args="$options_with_args
			--args
			--config-add
			--config-rm
			--constraint-add
			--constraint-rm
			--container-label-add
			--container-label-rm
			--dns-add
			--dns-option-add
			--dns-option-rm
			--dns-rm
			--dns-search-add
			--dns-search-rm
			--env-add
			--env-rm
			--generic-resource-add
			--generic-resource-rm
			--group-add
			--group-rm
			--host-add
			--host-rm
			--image
			--label-add
			--label-rm
			--mount-add
			--mount-rm
			--network-add
			--network-rm
			--placement-pref-add
			--placement-pref-rm
			--publish-add
			--publish-rm
			--rollback
			--secret-add
			--secret-rm
			--sysctl-add
			--sysctl-rm
			--ulimit-add
			--ulimit-rm
		"

		boolean_options="$boolean_options
			--force
		"

		case "$prev" in
			--env-rm)
				COMPREPLY=( $( compgen -e -- "$cur" ) )
				return
				;;
			--image)
				__docker_complete_images --repo --tag --id
				return
				;;
		esac
	fi

	local strategy=$(__docker_map_key_of_current_option '--placement-pref|--placement-pref-add|--placement-pref-rm')
	case "$strategy" in
		spread)
			COMPREPLY=( $( compgen -W "engine.labels node.labels" -S . -- "${cur##*=}" ) )
			__docker_nospace
			return
			;;
	esac

	case "$prev" in
		--cap-add)
			__docker_complete_capabilities_addable
			return
			;;
		--cap-drop)
			__docker_complete_capabilities_droppable
			return
			;;
		--config|--config-add|--config-rm)
			__docker_complete_configs
			return
			;;
		--endpoint-mode)
			COMPREPLY=( $( compgen -W "dnsrr vip" -- "$cur" ) )
			return
			;;
		--env|-e|--env-add)
			# we do not append a "=" here because "-e VARNAME" is legal systax, too
			COMPREPLY=( $( compgen -e -- "$cur" ) )
			__docker_nospace
			return
			;;
		--group|--group-add|--group-rm)
			COMPREPLY=( $(compgen -g -- "$cur") )
			return
			;;
		--host|--host-add|--host-rm)
			case "$cur" in
				*:)
					__docker_complete_resolved_hostname
					return
					;;
			esac
			;;
		--isolation)
			__docker_complete_isolation
			return
			;;
		--log-driver)
			__docker_complete_log_drivers
			return
			;;
		--log-opt)
			__docker_complete_log_options
			return
			;;
		--network|--network-add|--network-rm)
			__docker_complete_networks
			return
			;;
		--placement-pref|--placement-pref-add|--placement-pref-rm)
			COMPREPLY=( $( compgen -W "spread" -S = -- "$cur" ) )
			__docker_nospace
			return
			;;
		--restart-condition)
			COMPREPLY=( $( compgen -W "any none on-failure" -- "$cur" ) )
			return
			;;
		--rollback-failure-action)
			COMPREPLY=( $( compgen -W "continue pause" -- "$cur" ) )
			return
			;;
		--secret|--secret-add|--secret-rm)
			__docker_complete_secrets
			return
			;;
		--stop-signal)
			__docker_complete_signals
			return
			;;
		--update-failure-action)
			COMPREPLY=( $( compgen -W "continue pause rollback" -- "$cur" ) )
			return
			;;
		--ulimit|--ulimit-add)
			__docker_complete_ulimits
			return
			;;
		--ulimit-rm)
			__docker_complete_ulimits --rm
			return
			;;
		--update-order|--rollback-order)
			COMPREPLY=( $( compgen -W "start-first stop-first" -- "$cur" ) )
			return
			;;
		--user|-u)
			__docker_complete_user_group
			return
			;;
		$(__docker_to_extglob "$options_with_args") )
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "$boolean_options $options_with_args" -- "$cur" ) )
			;;
		*)
			local counter=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" )
			if [ "$subcommand" = "update" ] ; then
				if [ "$cword" -eq "$counter" ]; then
					__docker_complete_services
				fi
			else
				if [ "$cword" -eq "$counter" ]; then
					__docker_complete_images --repo --tag --id
				fi
			fi
			;;
	esac
}

_docker_swarm() {
	local subcommands="
		ca
		init
		join
		join-token
		leave
		unlock
		unlock-key
		update
	"
	__docker_subcommands "$subcommands" && return

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
			;;
	esac
}

_docker_swarm_ca() {
	case "$prev" in
		--ca-cert|--ca-key)
			_filedir
			return
			;;
		--cert-expiry|--external-ca)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--ca-cert --ca-key --cert-expiry --detach -d --external-ca --help --quiet -q --rotate" -- "$cur" ) )
			;;
	esac
}

_docker_swarm_init() {
	case "$prev" in
		--advertise-addr)
			if [[ $cur == *: ]] ; then
				COMPREPLY=( $( compgen -W "2377" -- "${cur##*:}" ) )
			else
				__docker_complete_local_interfaces
				__docker_nospace
			fi
			return
			;;
		--availability)
			COMPREPLY=( $( compgen -W "active drain pause" -- "$cur" ) )
			return
			;;
		--cert-expiry|--data-path-port|--default-addr-pool|--default-addr-pool-mask-length|--dispatcher-heartbeat|--external-ca|--max-snapshots|--snapshot-interval|--task-history-limit )
			return
			;;
		--data-path-addr)
			__docker_complete_local_interfaces
			return
			;;
		--listen-addr)
			if [[ $cur == *: ]] ; then
				COMPREPLY=( $( compgen -W "2377" -- "${cur##*:}" ) )
			else
				__docker_complete_local_interfaces --add 0.0.0.0
				__docker_nospace
			fi
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--advertise-addr --autolock --availability --cert-expiry --data-path-addr --data-path-port --default-addr-pool --default-addr-pool-mask-length --dispatcher-heartbeat --external-ca --force-new-cluster --help --listen-addr --max-snapshots --snapshot-interval --task-history-limit " -- "$cur" ) )
			;;
	esac
}

_docker_swarm_join() {
	case "$prev" in
		--advertise-addr)
			if [[ $cur == *: ]] ; then
				COMPREPLY=( $( compgen -W "2377" -- "${cur##*:}" ) )
			else
				__docker_complete_local_interfaces
				__docker_nospace
			fi
			return
			;;
		--availability)
			COMPREPLY=( $( compgen -W "active drain pause" -- "$cur" ) )
			return
			;;
		--data-path-addr)
			__docker_complete_local_interfaces
			return
			;;
		--listen-addr)
			if [[ $cur == *: ]] ; then
				COMPREPLY=( $( compgen -W "2377" -- "${cur##*:}" ) )
			else
				__docker_complete_local_interfaces --add 0.0.0.0
				__docker_nospace
			fi
			return
			;;
		--token)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--advertise-addr --availability --data-path-addr --help --listen-addr --token" -- "$cur" ) )
			;;
		*:)
			COMPREPLY=( $( compgen -W "2377" -- "${cur##*:}" ) )
			;;
	esac
}

_docker_swarm_join_token() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help --quiet -q --rotate" -- "$cur" ) )
			;;
		*)
			local counter=$( __docker_pos_first_nonflag )
			if [ "$cword" -eq "$counter" ]; then
				COMPREPLY=( $( compgen -W "manager worker" -- "$cur" ) )
			fi
			;;
	esac
}

_docker_swarm_leave() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--force -f --help" -- "$cur" ) )
			;;
	esac
}

_docker_swarm_unlock() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
	esac
}

_docker_swarm_unlock_key() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help --quiet -q --rotate" -- "$cur" ) )
			;;
	esac
}

_docker_swarm_update() {
	case "$prev" in
		--cert-expiry|--dispatcher-heartbeat|--external-ca|--max-snapshots|--snapshot-interval|--task-history-limit)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--autolock --cert-expiry --dispatcher-heartbeat --external-ca --help --max-snapshots --snapshot-interval --task-history-limit" -- "$cur" ) )
			;;
	esac
}

_docker_manifest() {
	local subcommands="
		annotate
		create
		inspect
		push
		rm
	"
	__docker_subcommands "$subcommands" && return

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
			;;
	esac
}

_docker_manifest_annotate() {
	case "$prev" in
		--arch)
			COMPREPLY=( $( compgen -W "
				386
				amd64
				arm
				arm64
				mips64
				mips64le
				ppc64le
				riscv64
				s390x" -- "$cur" ) )
			return
			;;
		--os)
			COMPREPLY=( $( compgen -W "
				darwin
				dragonfly
				freebsd
				linux
				netbsd
				openbsd
				plan9
				solaris
				windows" -- "$cur" ) )
			return
			;;
		--os-features|--variant)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--arch --help --os --os-features --variant" -- "$cur" ) )
			;;
		*)
			local counter=$( __docker_pos_first_nonflag "--arch|--os|--os-features|--variant" )
			if [ "$cword" -eq "$counter" ] || [ "$cword" -eq "$((counter + 1))" ]; then
				__docker_complete_images --force-tag --id
			fi
			;;
	esac
}

_docker_manifest_create() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--amend -a --help --insecure" -- "$cur" ) )
			;;
		*)
			__docker_complete_images --force-tag --id
			;;
	esac
}

_docker_manifest_inspect() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help --insecure --verbose -v" -- "$cur" ) )
			;;
		*)
			local counter=$( __docker_pos_first_nonflag )
			if [ "$cword" -eq "$counter" ] || [ "$cword" -eq "$((counter + 1))" ]; then
				__docker_complete_images --force-tag --id
			fi
			;;
	esac
}

_docker_manifest_push() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help --insecure --purge -p" -- "$cur" ) )
			;;
		*)
			local counter=$( __docker_pos_first_nonflag )
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_images --force-tag --id
			fi
			;;
	esac
}

_docker_manifest_rm() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			__docker_complete_images --force-tag --id
			;;
	esac
}

_docker_node() {
	local subcommands="
		demote
		inspect
		ls
		promote
		rm
		ps
		update
	"
	local aliases="
		list
		remove
	"
	__docker_subcommands "$subcommands $aliases" && return

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
			;;
	esac
}

_docker_node_demote() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			__docker_complete_nodes --filter role=manager
	esac
}

_docker_node_inspect() {
	case "$prev" in
		--format|-f)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--format -f --help --pretty" -- "$cur" ) )
			;;
		*)
			__docker_complete_nodes --add self
	esac
}

_docker_node_list() {
	_docker_node_ls
}

_docker_node_ls() {
	local key=$(__docker_map_key_of_current_option '--filter|-f')
	case "$key" in
		id)
			__docker_complete_nodes --cur "${cur##*=}" --id
			return
			;;
		label|node.label)
			return
			;;
		membership)
			COMPREPLY=( $( compgen -W "accepted pending" -- "${cur##*=}" ) )
			return
			;;
		name)
			__docker_complete_nodes --cur "${cur##*=}" --name
			return
			;;
		role)
			COMPREPLY=( $( compgen -W "manager worker" -- "${cur##*=}" ) )
			return
			;;
	esac

	case "$prev" in
		--filter|-f)
			COMPREPLY=( $( compgen -W "id label membership name node.label role" -S = -- "$cur" ) )
			__docker_nospace
			return
			;;
		--format)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--filter -f --format --help --quiet -q" -- "$cur" ) )
			;;
	esac
}

_docker_node_promote() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			__docker_complete_nodes --filter role=worker
	esac
}

_docker_node_remove() {
	_docker_node_rm
}

_docker_node_rm() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--force -f --help" -- "$cur" ) )
			;;
		*)
			__docker_complete_nodes
	esac
}

_docker_node_ps() {
	local key=$(__docker_map_key_of_current_option '--filter|-f')
	case "$key" in
		desired-state)
			COMPREPLY=( $( compgen -W "accepted running shutdown" -- "${cur##*=}" ) )
			return
			;;
		name)
			__docker_complete_services --cur "${cur##*=}" --name
			return
			;;
	esac

	case "$prev" in
		--filter|-f)
			COMPREPLY=( $( compgen -W "desired-state id label name" -S = -- "$cur" ) )
			__docker_nospace
			return
			;;
		--format)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--filter -f --format --help --no-resolve --no-trunc --quiet -q" -- "$cur" ) )
			;;
		*)
			__docker_complete_nodes --add self
			;;
	esac
}

_docker_node_update() {
	case "$prev" in
		--availability)
			COMPREPLY=( $( compgen -W "active drain pause" -- "$cur" ) )
			return
			;;
		--role)
			COMPREPLY=( $( compgen -W "manager worker" -- "$cur" ) )
			return
			;;
		--label-add|--label-rm)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--availability --help --label-add --label-rm --role" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag '--availability|--label-add|--label-rm|--role')
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_nodes
			fi
			;;
	esac
}

_docker_pause() {
	_docker_container_pause
}

_docker_plugin() {
	local subcommands="
		create
		disable
		enable
		inspect
		install
		ls
		push
		rm
		set
		upgrade
	"
	local aliases="
		list
		remove
	"
	__docker_subcommands "$subcommands $aliases" && return

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
			;;
	esac
}

_docker_plugin_create() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--compress --help" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag)
			if [ "$cword" -eq "$counter" ]; then
				# reponame
				return
			elif [ "$cword" -eq  "$((counter + 1))" ]; then
				_filedir -d
			fi
			;;
	esac
}

_docker_plugin_disable() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--force -f --help" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag)
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_plugins_installed --filter enabled=true
			fi
			;;
	esac
}

_docker_plugin_enable() {
	case "$prev" in
		--timeout)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help --timeout" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag '--timeout')
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_plugins_installed --filter enabled=false
			fi
			;;
	esac
}

_docker_plugin_inspect() {
	case "$prev" in
		--format|f)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--format -f --help" -- "$cur" ) )
			;;
		*)
			__docker_complete_plugins_installed
			;;
	esac
}

_docker_plugin_install() {
	case "$prev" in
		--alias)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--alias --disable --disable-content-trust=false --grant-all-permissions --help" -- "$cur" ) )
			;;
	esac
}

_docker_plugin_list() {
	_docker_plugin_ls
}

_docker_plugin_ls() {
	local key=$(__docker_map_key_of_current_option '--filter|-f')
	case "$key" in
		capability)
			COMPREPLY=( $( compgen -W "authz ipamdriver logdriver metricscollector networkdriver volumedriver" -- "${cur##*=}" ) )
			return
			;;
		enabled)
			COMPREPLY=( $( compgen -W "false true" -- "${cur##*=}" ) )
			return
			;;
	esac

	case "$prev" in
		--filter|-f)
			COMPREPLY=( $( compgen -S = -W "capability enabled" -- "$cur" ) )
			__docker_nospace
			return
			;;
		--format)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--filter -f --format --help --no-trunc --quiet -q" -- "$cur" ) )
			;;
	esac
}

_docker_plugin_push() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag)
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_plugins_installed
			fi
			;;
	esac
}

_docker_plugin_remove() {
	_docker_plugin_rm
}

_docker_plugin_rm() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--force -f --help" -- "$cur" ) )
			;;
		*)
			__docker_complete_plugins_installed
			;;
	esac
}

_docker_plugin_set() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag)
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_plugins_installed
			fi
			;;
	esac
}

_docker_plugin_upgrade() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--disable-content-trust --grant-all-permissions --help --skip-remote-check" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag)
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_plugins_installed
				__ltrim_colon_completions "$cur"
			elif [ "$cword" -eq  "$((counter + 1))" ]; then
				local plugin_images="$(__docker_plugins_installed)"
				COMPREPLY=( $(compgen -S : -W "${plugin_images%:*}" -- "$cur") )
				__docker_nospace
			fi
			;;
	esac
}


_docker_port() {
	_docker_container_port
}

_docker_ps() {
	_docker_container_ls
}

_docker_pull() {
	_docker_image_pull
}

_docker_push() {
	_docker_image_push
}

_docker_rename() {
	_docker_container_rename
}

_docker_restart() {
	_docker_container_restart
}

_docker_rm() {
	_docker_container_rm
}

_docker_rmi() {
	_docker_image_rm
}

_docker_run() {
	_docker_container_run
}

_docker_save() {
	_docker_image_save
}


_docker_secret() {
	local subcommands="
		create
		inspect
		ls
		rm
	"
	local aliases="
		list
		remove
	"
	__docker_subcommands "$subcommands $aliases" && return

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
			;;
	esac
}

_docker_secret_create() {
	case "$prev" in
		--driver|-d|--label|-l)
			return
			;;
		--template-driver)
			COMPREPLY=( $( compgen -W "golang" -- "$cur" ) )
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--driver -d --help --label -l --template-driver" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag '--driver|-d|--label|-l|--template-driver')
			if [ "$cword" -eq "$((counter + 1))" ]; then
				_filedir
			fi
			;;
	esac
}

_docker_secret_inspect() {
	case "$prev" in
		--format|-f)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--format -f --help --pretty" -- "$cur" ) )
			;;
		*)
			__docker_complete_secrets
			;;
	esac
}

_docker_secret_list() {
	_docker_secret_ls
}

_docker_secret_ls() {
	local key=$(__docker_map_key_of_current_option '--filter|-f')
	case "$key" in
		id)
			__docker_complete_secrets --cur "${cur##*=}" --id
			return
			;;
		name)
			__docker_complete_secrets --cur "${cur##*=}" --name
			return
			;;
	esac

	case "$prev" in
		--filter|-f)
			COMPREPLY=( $( compgen -S = -W "id label name" -- "$cur" ) )
			__docker_nospace
			return
			;;
		--format)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--format --filter -f --help --quiet -q" -- "$cur" ) )
			;;
	esac
}

_docker_secret_remove() {
	_docker_secret_rm
}

_docker_secret_rm() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			__docker_complete_secrets
			;;
	esac
}



_docker_search() {
	local key=$(__docker_map_key_of_current_option '--filter|-f')
	case "$key" in
		is-automated)
			COMPREPLY=( $( compgen -W "false true" -- "${cur##*=}" ) )
			return
			;;
		is-official)
			COMPREPLY=( $( compgen -W "false true" -- "${cur##*=}" ) )
			return
			;;
	esac

	case "$prev" in
		--filter|-f)
			COMPREPLY=( $( compgen -S = -W "is-automated is-official stars" -- "$cur" ) )
			__docker_nospace
			return
			;;
		--format|--limit)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--filter -f --format --help --limit --no-trunc" -- "$cur" ) )
			;;
	esac
}


_docker_stack() {
	local subcommands="
		config
		deploy
		ls
		ps
		rm
		services
	"
	local aliases="
		down
		list
		remove
		up
	"

	__docker_subcommands "$subcommands $aliases" && return

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
			;;
	esac
}

_docker_stack_config() {
	case "$prev" in
		--compose-file|-c)
			_filedir yml
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--compose-file -c --help --skip-interpolation" -- "$cur" ) )
			;;
  esac
}

_docker_stack_deploy() {
	case "$prev" in
		--compose-file|-c)
			_filedir yml
			return
			;;
		--resolve-image)
			COMPREPLY=( $( compgen -W "always changed never" -- "$cur" ) )
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--compose-file -c --help --prune --resolve-image --with-registry-auth" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag '--compose-file|-c|--resolve-image')
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_stacks
			fi
			;;
	esac
}

_docker_stack_down() {
	_docker_stack_rm
}

_docker_stack_list() {
	_docker_stack_ls
}

_docker_stack_ls() {
	case "$prev" in
		--format)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--format --help" -- "$cur" ) )
			;;
	esac
}

_docker_stack_ps() {
	local key=$(__docker_map_key_of_current_option '--filter|-f')
	case "$key" in
		desired-state)
			COMPREPLY=( $( compgen -W "accepted running shutdown" -- "${cur##*=}" ) )
			return
			;;
		id)
			__docker_complete_stacks --cur "${cur##*=}" --id
			return
			;;
		name)
			__docker_complete_stacks --cur "${cur##*=}" --name
			return
			;;
	esac

	case "$prev" in
		--filter|-f)
			COMPREPLY=( $( compgen -S = -W "id name desired-state" -- "$cur" ) )
			__docker_nospace
			return
			;;
		--format)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--filter -f --format --help --no-resolve --no-trunc --quiet -q" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag '--filter|-f|--format')
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_stacks
			fi
			;;
	esac
}

_docker_stack_remove() {
	_docker_stack_rm
}

_docker_stack_rm() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			__docker_complete_stacks
			;;
	esac
}

_docker_stack_services() {
	local key=$(__docker_map_key_of_current_option '--filter|-f')
	case "$key" in
		id)
			__docker_complete_services --cur "${cur##*=}" --id
			return
			;;
		label)
			return
			;;
		name)
			__docker_complete_services --cur "${cur##*=}" --name
			return
			;;
	esac

	case "$prev" in
		--filter|-f)
			COMPREPLY=( $( compgen -S = -W "id label name" -- "$cur" ) )
			__docker_nospace
			return
			;;
		--format)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--filter -f --format --help --quiet -q" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag '--filter|-f|--format')
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_stacks
			fi
			;;
	esac
}

_docker_stack_up() {
	_docker_stack_deploy
}


_docker_start() {
	_docker_container_start
}

_docker_stats() {
	_docker_container_stats
}

_docker_stop() {
	_docker_container_stop
}


_docker_system() {
	local subcommands="
		df
		events
		info
		prune
	"
	__docker_subcommands "$subcommands" && return

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
			;;
	esac
}

_docker_system_df() {
	case "$prev" in
		--format)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--format --help --verbose -v" -- "$cur" ) )
			;;
	esac
}

_docker_system_events() {
	local key=$(__docker_map_key_of_current_option '-f|--filter')
	case "$key" in
		container)
			__docker_complete_containers_all --cur "${cur##*=}"
			return
			;;
		daemon)
			local name=$(__docker_q info | sed -n 's/^\(ID\|Name\): //p')
			COMPREPLY=( $( compgen -W "$name" -- "${cur##*=}" ) )
			return
			;;
		event)
			COMPREPLY=( $( compgen -W "
				attach
				commit
				connect
				copy
				create
				delete
				destroy
				detach
				die
				disable
				disconnect
				enable
				exec_create
				exec_detach
				exec_die
				exec_start
				export
				health_status
				import
				install
				kill
				load
				mount
				oom
				pause
				pull
				push
				reload
				remove
				rename
				resize
				restart
				save
				start
				stop
				tag
				top
				unmount
				unpause
				untag
				update
			" -- "${cur##*=}" ) )
			return
			;;
		image)
			__docker_complete_images --cur "${cur##*=}" --repo --tag
			return
			;;
		network)
			__docker_complete_networks --cur "${cur##*=}"
			return
			;;
		node)
			__docker_complete_nodes --cur "${cur##*=}"
			return
			;;
		scope)
			COMPREPLY=( $( compgen -W "local swarm" -- "${cur##*=}" ) )
			return
			;;
		type)
			COMPREPLY=( $( compgen -W "config container daemon image network node plugin secret service volume" -- "${cur##*=}" ) )
			return
			;;
		volume)
			__docker_complete_volumes --cur "${cur##*=}"
			return
			;;
	esac

	case "$prev" in
		--filter|-f)
			COMPREPLY=( $( compgen -S = -W "container daemon event image label network node scope type volume" -- "$cur" ) )
			__docker_nospace
			return
			;;
		--since|--until)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--filter -f --help --since --until --format" -- "$cur" ) )
			;;
	esac
}

_docker_system_info() {
	case "$prev" in
		--format|-f)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--format -f --help" -- "$cur" ) )
			;;
	esac
}

_docker_system_prune() {
	case "$prev" in
		--filter)
			COMPREPLY=( $( compgen -W "label label! until" -S = -- "$cur" ) )
			__docker_nospace
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--all -a --force -f --filter --help --volumes" -- "$cur" ) )
			;;
	esac
}


_docker_tag() {
	_docker_image_tag
}


_docker_trust() {
	local subcommands="
		inspect
		revoke
		sign
	"
	__docker_subcommands "$subcommands" && return

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
			;;
	esac
}

_docker_trust_inspect() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help --pretty" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag)
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_images --repo --tag
			fi
			;;
	esac
}

_docker_trust_revoke() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help --yes -y" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag)
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_images --repo --tag
			fi
			;;
	esac
}

_docker_trust_sign() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help --local" -- "$cur" ) )
			;;
		*)
			local counter=$(__docker_pos_first_nonflag)
			if [ "$cword" -eq "$counter" ]; then
				__docker_complete_images --force-tag --id
			fi
			;;
	esac
}


_docker_unpause() {
	_docker_container_unpause
}

_docker_update() {
	_docker_container_update
}

_docker_top() {
	_docker_container_top
}

_docker_version() {
	case "$prev" in
		--format|-f)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--format -f --help" -- "$cur" ) )
			;;
	esac
}

_docker_volume_create() {
	case "$prev" in
		--driver|-d)
			__docker_complete_plugins_bundled --type Volume
			return
			;;
		--label|--opt|-o)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--driver -d --help --label --opt -o" -- "$cur" ) )
			;;
	esac
}

_docker_volume_inspect() {
	case "$prev" in
		--format|-f)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--format -f --help" -- "$cur" ) )
			;;
		*)
			__docker_complete_volumes
			;;
	esac
}

_docker_volume_list() {
	_docker_volume_ls
}

_docker_volume_ls() {
	local key=$(__docker_map_key_of_current_option '--filter|-f')
	case "$key" in
		dangling)
			COMPREPLY=( $( compgen -W "true false" -- "${cur##*=}" ) )
			return
			;;
		driver)
			__docker_complete_plugins_bundled --cur "${cur##*=}" --type Volume
			return
			;;
		name)
			__docker_complete_volumes --cur "${cur##*=}"
			return
			;;
	esac

	case "$prev" in
		--filter|-f)
			COMPREPLY=( $( compgen -S = -W "dangling driver label name" -- "$cur" ) )
			__docker_nospace
			return
			;;
		--format)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--filter -f --format --help --quiet -q" -- "$cur" ) )
			;;
	esac
}

_docker_volume_prune() {
	case "$prev" in
		--filter)
			COMPREPLY=( $( compgen -W "label label!" -S = -- "$cur" ) )
			__docker_nospace
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--all -a --filter --force -f --help" -- "$cur" ) )
			;;
	esac
}

_docker_volume_remove() {
	_docker_volume_rm
}

_docker_volume_rm() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--force -f --help" -- "$cur" ) )
			;;
		*)
			__docker_complete_volumes
			;;
	esac
}

_docker_volume() {
	local subcommands="
		create
		inspect
		ls
		prune
		rm
	"
	local aliases="
		list
		remove
	"
	__docker_subcommands "$subcommands $aliases" && return

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
		*)
			COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
			;;
	esac
}

_docker_wait() {
	_docker_container_wait
}

_docker() {
	local previous_extglob_setting=$(shopt -p extglob)
	shopt -s extglob

	local management_commands=(
		builder
		config
		container
		context
		image
		manifest
		network
		node
		plugin
		secret
		service
		stack
		swarm
		system
		trust
		volume
	)

	local top_level_commands=(
		build
		login
		logout
		run
		search
		version
	)

	local legacy_commands=(
		attach
		commit
		cp
		create
		diff
		events
		exec
		export
		history
		images
		import
		info
		inspect
		kill
		load
		logs
		pause
		port
		ps
		pull
		push
		rename
		restart
		rm
		rmi
		save
		start
		stats
		stop
		tag
		top
		unpause
		update
		wait
	)

	# Create completion functions for all registered plugins
	local known_plugin_commands=()
	local plugin_name=""
	for plugin_path in $(__docker_plugins_path); do
		plugin_name=$(basename "$plugin_path" | sed 's/ *$//')
		plugin_name=${plugin_name#docker-}
		plugin_name=${plugin_name%%.*}
		eval "_docker_${plugin_name}() { __docker_complete_plugin \"${plugin_path}\"; }"
		known_plugin_commands+=(${plugin_name})
	done

	local experimental_server_commands=(
		checkpoint
	)

	local commands=(${management_commands[*]} ${top_level_commands[*]} ${known_plugin_commands[*]})
	[ -z "${DOCKER_HIDE_LEGACY_COMMANDS-}" ] && commands+=(${legacy_commands[*]})

	# These options are valid as global options for all client commands
	# and valid as command options for `docker daemon`
	local global_boolean_options="
		--debug -D
		--tls
		--tlsverify
	"
	local global_options_with_args="
		--config
		--context -c
		--host -H
		--log-level -l
		--tlscacert
		--tlscert
		--tlskey
	"

	# variables to cache server info, populated on demand for performance reasons
	local info_fetched server_experimental server_os

	local host config context

	COMPREPLY=()
	local cur prev words cword
	_get_comp_words_by_ref -n : cur prev words cword

	local command='docker' command_pos=0 subcommand_pos
	local counter=1
	while [ "$counter" -lt "$cword" ]; do
		case "${words[$counter]}" in
			docker)
				return 0
				;;
			# save host so that completion can use custom daemon
			--host|-H)
				(( counter++ ))
				host="${words[$counter]}"
				;;
			# save config so that completion can use custom configuration directories
			--config)
				(( counter++ ))
				config="${words[$counter]}"
				;;
			# save context so that completion can use custom daemon
			--context|-c)
				(( counter++ ))
				context="${words[$counter]}"
				;;
			$(__docker_to_extglob "$global_options_with_args") )
				(( counter++ ))
				;;
			-*)
				;;
			=)
				(( counter++ ))
				;;
			*)
				command="${words[$counter]}"
				command_pos=$counter
				break
				;;
		esac
		(( counter++ ))
	done

	local binary="${words[0]}"
	if [[ $binary == ?(*/)dockerd ]] ; then
		# for the dockerd binary, we reuse completion of `docker daemon`.
		# dockerd does not have subcommands and global options.
		command=daemon
		command_pos=0
	fi

	local completions_func=_docker_${command//-/_}
	declare -F $completions_func >/dev/null && $completions_func

	eval "$previous_extglob_setting"
	return 0
}

eval "$__docker_previous_extglob_setting"
unset __docker_previous_extglob_setting

complete -F _docker docker docker.exe dockerd dockerd.exe
```

`/home/setuc/.dotfiles/bash/aliases/docker.aliases`:

```aliases
# Docker aliases  
alias dps='docker ps'  
alias dpsa='docker ps -a'  
alias di='docker images'  
alias db='docker build'  
alias dr='docker run'  
alias drm='docker rm $(docker ps -a -q)'  
alias drmi='docker rmi $(docker images -q)'  
```

`/home/setuc/.dotfiles/bash/aliases/function_aliases.aliases`:

```aliases
# ~/.aliases/function_aliases.aliases  
  
# Aliases for functions  
alias dvi='download_verify_install'  
alias coenv='create_conda_env'  
alias camlenv='create_aml_env' 
```

`/home/setuc/.dotfiles/bash/aliases/git.aliases`:

```aliases
# Git aliases  
alias gs='git status'  
alias ga='git add'  
alias gb='git branch'  
alias gc='git commit'  
alias gco='git checkout'  
alias gl='git log --oneline --graph --all --decorate'  
alias gd='git diff'  
alias gp='git push'  
alias gpo='git push origin'  
alias gpl='git pull'  
```

`/home/setuc/.dotfiles/bash/aliases/azure.aliases`:

```aliases
# Azure CLI aliases  
alias azlogin='az login'  
alias azrg='az group list -o table'  
alias azvm='az vm list -d -o table'  
alias azaks='az aks list -o table' 

#Azure Machine Learing Conda aliases
alias coap='conda activate azureml_py310_sdkv2'
alias codp='conda deactivate azureml_py310_sdkv2'
alias coatf='conda activate azureml_py38_PT_TF'
alias codtf='conda deactivate azureml_py38_PT_TF'
alias coup='conda env update --file environment.yml --prune'

```

`/home/setuc/.dotfiles/bash/aliases/kubernetes.aliases`:

```aliases
# Kubernetes aliases  
alias k='kubectl'  
alias kgp='kubectl get pods'  
alias kgd='kubectl get deployments'  
  

```

`/home/setuc/.dotfiles/bash/aliases/general.aliases`:

```aliases
# General aliases  
alias ll='ls -alF'  
alias la='ls -A'  
alias l='ls -CF'  
alias ..='cd ..'  
alias ...='cd ../..'  
alias grep='grep --color=auto'  

# Custom aliases  
alias myip='curl ifconfig.me'  
alias ups='sudo apt update && sudo apt upgrade -y && sudo apt autoremove -y && sudo apt autoclean'

 
# Editing aliases  
alias v='vim'  
alias vimrc='vim ~/.vimrc'  
alias bashrc='vim ~/.bashrc' 

# Python aliases  
alias py='python3'
alias pip='pip3'
alias venv='python3 -m venv'
alias activate='source ./venv/bin/activate'

```